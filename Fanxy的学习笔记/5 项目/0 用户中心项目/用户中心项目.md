# 用户中心项目

# 一. 项目前言

## 1. 企业做项目流程

需求分析 => 设计（概要设计、详细设计）=> 技术选型 => 

初始化 / 引入需要的技术 => 写 Demo => 写代码

（实现业务逻辑） => 测试（单元测试、系统测试）=> 代码提交 / 代码评审 => 部署 => 发布上线

1. 需求分析
2. 设计（概要设计、详细设计）
3. 技术选型
4. 初始化 / 引入需要的技术
5. 写 Demo
6. 写代码（实现业务逻辑）
7. 测试（单元测试、系统测试）
8. 代码提交 / 代码评审
9. 部署
10. 发布上线



## 2. 需求分析

1. **登录 / 注册**
2. **用户管理（仅管理员可见）对用户的查询或者修改**
3. 用户校验（ **仅星球用户** ）

这里权限管理就不管了，目前后台没有什么特别多的角色，还可以有比如封号黑名单等，待日后拓展。。。



## 3. 技术选型

**前端：**

- HTML+CSS+JavaScript 三件套

- React 开发框架

- 组件库 Ant Design

- `Umi` 开发框架

- `Umi Request` 开发框架 `Ant Design Pro`（现成的管理系统）

**后端：**

- java
- spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）
- springmvc（web 框架，提供接口访问、restful接口等能力）
- mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）
- mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）
- springboot（**快速启动** / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）
- junit 单元测试库
- mysql 数据库

部署：服务器 / 容器（平台）

**三种初始化 JAVA 项目的方式**

1. `github` 现成代码
2. `Springboot` 官方生成器
3. 直接在 IDEA 开发工具生成 【√】

- `lombok` 
- `dvtools`
- `mysql`
- `springweb`
- `mybatis`

自定义的日后加



## 4. 初始化项目

### 4.1. 前端初始化

1. Nodejs版本18 【当前的稳定版】

官方文档: https://pro.ant.design/

这个框架可能会更新，一定要跟着官方文档来: https://pro.ant.design/zh-CN/docs/getting-started/

首先下载 Node.js 18版本，可以去官网下载: https://nodejs.org/，记得选择稳定版本（不要选20)

>  nvm工具可以快捷切换node.js的版本

切换 `npm` 下包镜像源
在终端中运行下面这行命令

查看当前的下包镜像源

```sh
npm config get registry
```

将下包的镜像源切换为淘宝镜像源

```sh
npm config set registry=http://registry.npm.taobao.org/
```

检查镜像源是否下载成功

```sh
npm config get registry
```

为了更方便的切换下镜像源，我们可以安装 `nrm` 这个小工具，利用 `nrm` 提供的终端命令，可以快速查看和切换下包的镜像源

```sh
npm i nrm -g

nrm ls

nrm use taobao
```

```sh
# 使用 npm
npm i @ant-design/pro-cli -g
pro create xy-usercenter-frontend
```

> 如果没有下载 `yarn`【一个依赖管理工具】，可以执行下面的命令下载
>
> ```sh
> npm install --global yarn
> ```
>
> 然后通过`webstorm`进入`xy-usercenter-frontend`文件夹，打开terminal，自动安装相关依赖 安装依赖完成后，找到`package.json`。scripts下有很多脚本，找到start并运行。即可启动ant design pro

**这里我遇到了一个报错**

`'cross-env' is not recognized as an internal or external command, operable program or batch file.`

**发现这个问题的原因是由于windows电脑造成的，在windows电脑上默认是无法使用 `cross-env` ，需要手动安装，那行吧，安装一下**

然后又出现问题，其实这些问题，`webstorm` 都自动分析了，在右下角，让我们去安装依赖。

类似这种的无法识别参数，这些问题其实都是因为各种原因，比如网络啊什么的**安装不完全导致的**，我的建议是重新安装，甚至是 **换一种安装方式**；

```sh
cd 项目文件夹
 
npm install
```

**但是安装实在是太慢了，直接换`cnpm`，`CNPM` 是中国 `npm` 镜像的客户端。<font color='red'>换的前提是，你的版本能对应，如果太新，还是寄</font>**

```sh
npm install cnpm -g --registry=https://registry.npm.taobao.org
```

```sh
cd 项目文件夹
 
cnpm install
```

**这里如果node.js版本低于 16.14 也会报错，可以通过如下命令进行查看，如果不满足就去上面下载新版本**

```sh
node -v
```

**这里官方给我们提供了一键删除国际化的命令**

![7.png](./用户中心项目.assets/7.png)

**但是报错了**

![8.png](./用户中心项目.assets/8.png)

**问题解决**

**<font color='red'>任何开源项目的报错，都可以直接问作者（官方团队）或者搜 `github issues区`，直接这里复制报错部分的信息，在`github 的 issues区`，发现找到了官方给出的解决办法</font>**

步骤:

1．找到开源地址:               https://github.com/ant-design/ant-design-pro

2．搜索issues:                   https://github.com/ant-design/ant-design-pro/issues/10452

3．前端本地执行: 

````sh
yarn add eslint-config-prettier --dev yarn add eslint-plugin-unicorn --dev
````

**<font color='red'>修改`node_modules/@umijs/lint/dist/config/eslint/index.js`，注释掉 `es` 2022 true</font>**

**路由不显示名称**

给 `config/route.ts` 的路由加 `name`

这里类似 `springboot` 框架底层帮我们自动导入了很多依赖，需要根据readme文件，运行它写的 `npm install` 或者是 `yarn` 安装依赖

![1](./用户中心项目.assets/9.png)

这里大致介绍了一下目录，其实 BI项目有笔记，这里迁移过来

##### 1. 前端目录

<img src="./用户中心项目.assets/42.png" alt="42.png" style="zoom:80%;" />

##### 2. 逐步更改代码模块

**因为 `start` 是以 `mock` 提供虚拟数据来启动，有了后端的情况下可以删除 `mock` 数据以 `dev` 方式启动**

<img src="./用户中心项目.assets/43.png" alt="43.png" style="zoom:80%;" />

![44.png](./用户中心项目.assets/44.png)

- **`icons` 文件夹直接删除，项目自带的图标**

- **`scripts` 文件夹 ：应该是 `umi4` 新版本的一些东西，不用管**

- **`public/CNAME` ：可以替换我们的域名**

- **这里的图标和logo可以替换成自己的，来搭建我们自己的项目，可以去下面的页面找替换的图**

  ```apl
  https://iconfont.cn
  ---------------------或者是字节跳动的-----------------------
  https://iconpark.oceanengine.com/official
  ```

  **项目里面是 `svg` 图标，所以就下 `svg` 的，全局搜索 `pro_icon.svg` 发现这个文件全局没用到，直接删**

  **而网站小图标 `favicon.ico` 可以直接下一个通过网上的工具转换成 `ico` 格式，或者直接改后缀，这里科普 4k 就有点大了， 小于 2k 比较好**

![45.png](./用户中心项目.assets/45.png)

**`src`内文件夹类文件**

**组件是可以复用的，页面是唯一的**

<img src="./用户中心项目.assets/46.png" alt="46.png" style="zoom: 80%;" />

**`src`内非文件夹类文件**

<img src="./用户中心项目.assets/47.png" alt="47.png"  />

**最后外部的文件**

![48.png](./用户中心项目.assets/48.png)

**这里默认没有开启美化，结合上面的外部文件，我们打开即可完成。**

![49.png](./用户中心项目.assets/49.png)

**然后进行项目名称全局替换，这里找到 `config/defaultSettings.ts`【只是为了懒得打字】，内部的 `Ant Design Pro` 和 `Ant Design`，全局替换成我们想要的名称，这里我选择 `XY の 后台管理系统` 。**

**当然发现网页下面的版权说明等，还是蚂蚁集团，这里也是全局搜索，替换自己的。以及网页未来能看到的可替换文本都是同样方式替换。**

**如果启动不了，<font color='red'>注释【别删，后面还是得配置对接后端生成接口】</font> 这个，因为前面删了 `openapi` 的 `json` 配置**

![1.png](./用户中心项目.assets/1.png)



## 5. 数据库设计和简单测试

什么是数据库？存储数据

数据库里有什么？数据表（理解为 excel 表格）

java 操作数据库？程序代替人工



### 5.1 **什么是设计数据库表**？

有哪些表（模型）？

表中有哪些字段？

字段的类型？

数据库字段添加索引？

表与表之间的关联？

举例：性别是否需要加索引？

yarn add @umijs/preset-ui -D 



### 5.2 **用户表设计**

主要字段：

`id`（主键）`bigint`

`user_name` 昵称 `varchar`

`user_account` 登录账号 `varchar`

`avatar_url` 头像 `varchar`

`gender` 性别 `tinyint`

`user_password` 密码 `varchar`

`phone` 电话 `varchar`

`email` 邮箱 `varchar`

`user_status` 用户状态 `int` 0 - 正常

`create_time` 创建时间（数据插入时间）`datetime`

`update_time` 更新时间（数据更新时间）`datetime`

`deleted` 是否删除 0  1（逻辑删除）`tinyint`

`user_role` 用户角色 0 - 普通用户 1 - 管理员

`create_time` 创建时间 datetime

`update_time` 更新时间 datetime

**一般网上都推荐数据库字段不要设计的有 is 开头，可能序列化会出问题， 所以这里我就改掉了，同时数据库字段我也把驼峰改成了标准的下划线**

```sql
create database if not exists xycenter;
use xycenter;

drop table if exists user;

create table if not exists user
(
    id            bigint auto_increment comment 'id' primary key,
    user_name     varchar(256)                       null comment '用户昵称',
    user_account   varchar(256)                       null comment '账号',
    user_password varchar(512)                       not null comment '密码',
    avatar_url     varchar(1024)                      null comment '用户头像',
    gender        tinyint                            null comment '性别',
    phone         varchar(128)                       null comment '电话',
    email         varchar(512)                       null comment '邮箱',
    user_status   int      default 0                 not null comment '状态 0[正常] 1[注销] 2[封号]',
    create_time   datetime default CURRENT_TIMESTAMP null comment '创建时间',
    update_time   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',
    deleted       tinyint  default 0                 not null comment '是否删除 0[否] 1[是]',
    user_role     int      default 0                 not null comment '用户角色 0[普通用户] 1[管理员] 2[VIP]',
    user_code     varchar(512)                       null comment '用户编号'
) comment '用户表' collate = utf8mb4_unicode_ci;
```



### 5.3 自动生成器的使用

把项目结构先初步整理

![2.png](./用户中心项目.assets/2.png)

第一个路径填写项目的即可

![3](./用户中心项目.assets/3.png)

`MyBatisX` 插件，自动根据数据库生成：

`model`【domain：老版本】：实体对象

`mapper`：操作数据库的对象

`mapper.xml`：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL

`service`：包含常用的增删改查

`serviceImpl`：具体实现 service

从而提高开发效率！

![4.png](./用户中心项目.assets/4.png)

把对应的代码放到该放的包

![5.png](./用户中心项目.assets/5.png)

这里养成一个习惯，做好一个功能要先测试会不会有bug，使用 `alt + enter` 生成测试方法，默认的就行

![6.png](./用户中心项目.assets/6.png)

这里科普了一个检查代码规范的小插件 `sonalint`

以及一个一键生成所有 get set 方法的插件 `GenerateAllSetter`

快捷键提醒 同时能统计有多少次没有使用快捷键 `Key Promoter X`

**这里我还把用户的主键改成了雪花ID，然后删除改成了逻辑删除，对应的测试代码，可以使用 `alt + enter` 快速生成【对应路径空方法，测试方法还得自己写】**

配置逻辑删除

```yaml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置实体注解)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

![10.png](./用户中心项目.assets/10.png)

```java
@SpringBootTest
class UserServiceTest {

    @Resource
    private UserService userService;

    @Test
    void testAddUser() {
        User user = new User();
        user.setUserName("王大伟");
        user.setUserAccount("123456");
        user.setUserPassword("123");
        user.setAvatarUrl("");
        user.setGender(0);
        user.setPhone("123");
        user.setEmail("123@qq.com");
        user.setUserStatus(0);
        user.setCreateTime(new Date());
        user.setUpdateTime(new Date());
        user.setDeleted(0);
        user.setUserRole(0);
        user.setUserCode("233");

        boolean result = userService.save(user);
        Assertions.assertTrue(result);
    }
}
```



当然 `mybatis plus` 默认配置了驼峰转换，所以如果你不想转化可以改，具体看 `springboot` 第一节的部分



# 二. 基本【后端】功能初开发【登录注册管理】

1. 用户在前端输入账户和密码、以及校验码（todo）
2. 校验用户的账户、密码、校验密码，是否符合要求
   1. 非空
   2. 账户长度 **不小于** 4 位
   3. 密码就 **不小于** 8 位 【密码格式可以做正则】
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和校验密码相同
3. 对密码进行加密（密码千万不要直接以明文存储到数据库中）
4. 向数据库插入用户数据



## 1. 注册业务代码编写【第一版】

引入依赖

```xml
        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
```

> Apache Commons Lang3 是 Apache 软件基金会开发的一组 Java 工具类库，提供各种常用字符串处理、数学运算、数据转换、校验等常用功能实现的工具类

Java 中的**盐值和密码混淆都是用来提高密码安全性的防护措施。**盐值是一种用于增加密码破解难度的技术，在存储用户密码时，会将用户密码和一个随机生成的字符串（称为盐）进行组合，然后再进行加密存储。每个用户的盐值都是随机生成的，**这样可以防止攻击者使用相同的方式对一组用户的密码执行攻击。**在验证用户登录时，系统会使用相同的盐和用户输入的密码进行组合，并与存储的加密密码进行比对，以验证密码是否正确。



先给接口写登录方法 返回生成用户的主键 id ，如果为 -1 说明注册失败，未来可以写异常，然后更为返回异常页面

```java
long userRegister(String userAccount, String userPassword, String checkPassword);
```

**然后实现方法这里利用了 `Springboot` 自带的判断非空的工具类 `StringUtils` 的 `isAnyBlank()` 方法，可以同时判断多个是否为空**



**同时这里有一个思想，校验是否有相同账户的操作，应该放在所有的校验之后，因为这个校验需要走数据库进行查询，是否有账户相同的数据，如果有的话，就登录失败。我们应该尽可能让查询数据库的操作放在所有不走数据库之后，减小数据库的压力。**



**这里加密使用了 Spring 自带的加密函数，我们手动加了盐，然后对它进行加密，返回的是一个十六进制的数。然后数据库操作其实用 service 功能更多，但是 这里为了直观演示，也使用了注入 `UserMapper` 的方式进行演示。**  



**<font color='red'>第一版注册【此时只是返回 -1 未来应该对应做一个处理异常页面的类，然后返回异常】</font>**

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
        implements UserService {
    /**
     * 盐值 混淆密码
     */
    private static final String SALT = "My SALT";

    @Override
    public long userRegister(String userAccount, String userPassword, String checkPassword) {
        // 1. 校验
        // 非空 长度校验
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return -1;
        }
        if (userAccount.length() < 4) {
            return -1;
        }
        if (userPassword.length() < 8 || checkPassword.length() < 8) {
            return -1;
        }
        // 账户不能包含特殊字符 特殊字符使用正则表达式筛选
        String validPattern = "[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。 ，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return -1;
        }
        // 账户不能重复
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("user_account", userAccount);
        long count = this.count(queryWrapper);
        if (count > 0) {
            return -1;
        }
        // 校验密码和密码相同判断
        if (!userPassword.equals(checkPassword)) {
            return -1;
        }
        // 2. 加密
        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());
        // 3. 插入数据
        User user = new User();
        user.setUserAccount(userAccount);
        user.setUserPassword(encryptPassword);
        boolean saveResult = this.save(user);
        // 这里返回的是 long 类型 但是实际上我们实体类是 Long 类型 故加一重判断
        if (!saveResult) {
            return -1;
        }
        return 0;
    }
}
```



**对应的测试代码，可以使用 `alt + enter` 快速生成【对应路径空方法，测试方法还得自己写】**

```java
    @Test
    void testRegister() {

        // 1 非空检测
        Assertions.assertEquals(-1L, userService.userRegister("", "", ""));
        // 2 账号长度4位检测
        Assertions.assertEquals(-1L, userService.userRegister("123", "aaaaaaaa", "aaaaaaaa"));
        // 3 密码长度8位检测
        Assertions.assertEquals(-1L, userService.userRegister("fanxy", "a", "aaaaaaaa"));
        // 4 校验密码长度8位检测
        Assertions.assertEquals(-1L, userService.userRegister("fanxy2", "aaaaaaaa", "a"));
        // 5 账号特殊字符检测
        Assertions.assertEquals(-1L, userService.userRegister("fanxy3@", "aaaaaaaa", "aaaaaaaa"));
        // 6 账号重复检测
        Assertions.assertEquals(-1L, userService.userRegister("123456", "aaaaaaaa", "aaaaaaaa"));
        // 7 校验密码和密码相同检测
        Assertions.assertEquals(-1L, userService.userRegister("3152523562", "bbbbbbbb", "aaaaaaaa"));
        // 8 正常注册
        Assertions.assertEquals(0L, userService.userRegister("315144", "bbbbbbbb", "bbbbbbbb"));
    }
```



## 2. 登录业务代码编写【第一版】

### 2.1. **接口设计**

接受参数：用户账户、密码

请求类型：POST

请求体：JSON 格式的数据

> 请求参数很长时不建议用 get

返回值：用户信息（ **脱敏** ）



### 2.2. 登录逻辑

1. 校验用户账户和密码是否合法【先走合法判断防止所有请求打在 `mysql` 】
   1. 非空
   2. 账户长度 **不小于** 4 位
   3. 密码 **不小于** 8 位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码（注册时加密后的）去对比
3. 用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露
4. 我们要记录用户的登录态（`session`），将其存到服务器上（用后端 `SpringBoot` 框架封装的服务器 `tomcat` 去记录）【分布式用 `redis` 存储】

`cookie`

5. **返回脱敏后的用户信息**

> 脱敏：信息脱敏（Data Masking）是一种隐私保护技术，通过对敏感数据进行修改或者替换的方式，来保护数据的隐私和安全。信息脱敏通常应用于需要处理敏感数据的场景，例如测试、开发、分析等环境。在信息脱敏技术中，被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格式，以避免敏感数据泄露和数据窃取的风险，主要就是防止信息泄露，隐藏敏感信息



### 2.3. 如何知道是哪个用户登录了？

`javaweb` 这一块的知识

1. 连接服务器端后，得到一个 session 状态（匿名会话），返回给前端（用户已经有了会话，但是这个会在用户登录成功之后才会保存到Session）

2. 登录成功后，得到了登录成功的 session，并且给该session设置一些值（比如用户信息），返回给前端一个设置 cookie 的 命令

**session => cookie**

3. 前端接收到后端的命令后，设置 cookie，保存到浏览器内
4. 前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求
5. 后端拿到前端传来的 cookie，找到对应的 session
6. 后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）

逻辑删除：逻辑删除是指在数据库中不是真正删除记录，而是标记为已删除，使得这些记录在系统中看起来像已被删除。这比物理删除更加安全、可靠，也能够满足许多场景下的需求。



初步完成第一版登录和脱敏的 `Service` 层方法 **<font color='red'>【返回值的全局异常处理没有做 逻辑待完善 脱敏的细节没有处理，同时也没有给用户发送Cookie】</font>**

**下面的用户登录态键应该写到接口，这样 Controller 层想要调用的时候，才能直接通过依赖注入的 `userService` 直接使用。然后这么过渡思想，不如设计常量接口，这样能最大程度减少代码冗余，同时分工明确**

```java
	// 用户登录态键
	public static final String USER_LOGIN_STATE = "userLoginState";

	@Override
    public User userLogin(String userAccount, String userPassword, HttpServletRequest request) {
        // 1. 校验
        // 非空 长度校验
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;
        }
        if (userAccount.length() < 4) {
            return null;
        }
        if (userPassword.length() < 8) {
            return null;
        }
        // 账户不能包含特殊字符 特殊字符使用正则表达式筛选
        String validPattern = "[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。 ，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return null;
        }
        // 2. 加密
        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());
        // 查询用户是否存在
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("user_account", userAccount).eq("user_password", encryptPassword);
        User user = this.getOne(queryWrapper);
        // 用户不存在
        if (user == null) {
            log.info("user login failed, user_account can't match user_password");
            return null;
        }
        // 3. 给用户的信息脱敏
        User safetyUser = this.getSafetyUser(user);
        // 4. 记录用户的登录态
        request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser);
        return safetyUser;
    }

    @Override
    public User getSafetyUser(User originUser) {
        if (originUser == null) {
            return null;
        }
        User safetyUser = new User();
        safetyUser.setId(originUser.getId());
        safetyUser.setUserName(originUser.getUserName());
        safetyUser.setUserAccount(originUser.getUserAccount());
        safetyUser.setAvatarUrl(originUser.getAvatarUrl());
        safetyUser.setGender(originUser.getGender());
        safetyUser.setPhone(originUser.getPhone());
        safetyUser.setEmail(originUser.getEmail());
        safetyUser.setUserStatus(originUser.getUserStatus());
        safetyUser.setCreateTime(originUser.getCreateTime());
        safetyUser.setUserRole(originUser.getUserRole());
        safetyUser.setUserCode(originUser.getUserCode());
        return safetyUser;
    }
```



## 3. Controller层方法【第一版】

控制层 `Controller` 封装请求

`@RestController` 适用于编写 `restful` 风格的 `api`，**返回值默认为 `json` 类型** 

`application.yaml` **可以指定接口全局路径前缀【这里我没有指定】**

```yaml
servlet:
context-path: /api
```

同时我们要自己去新建一个类，专门封装我们 **前后端** 发送请求的 `Request` ，把其中的数据用 `JSON` 存储。

**注册**

```java
@Data
public class UserRegisterRequest implements Serializable {

    private static final long serialVersionUID = 3263730285932812205L;

    private String userAccount;

    private String userPassword;

    private String checkPassword;
}
```

**登录**

```java
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 9167179106887380991L;

    private String userAccount;

    private String userPassword;
}
```



这里可能会有一个疑惑，明明 `Service`层已经有了校验，为什么这里还要进行一个非空校验，**校验写在哪里？**

- `controller` 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）

- `service` 层是对业务逻辑的校验（有可能被 `controller` 之外的类调用）



```java
@RestController
@Slf4j
@RequestMapping("/user")
public class UserController {

    @Resource
    private UserService userService;

    @PostMapping("/register")
    public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) {
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return null;
        }
        return userService.userRegister(userAccount, userPassword, checkPassword);
    }

    @PostMapping("/login")
    public User userLogin(
            @RequestBody UserLoginRequest userLoginRequest,
            HttpServletRequest request) {
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;
        }
        return userService.userLogin(userAccount, userPassword, request);
    }
}
```



**不用 `swagger` 也可以使用 IDEA 自带的工具进行自测，可以从 `Controller` 的方法的小图标点进来，编辑内容类型，和请求头的信息即可自测。**

<img src="./用户中心项目.assets/11.png" alt="11.png" style="zoom:67%;" />



## 4. 用户管理方法

接口设计关键：必须鉴权！！！

1. 查询用户（允许根据用户名查询）【**这里先不做分页，未来再说**】
2. 删除用户

**Session过期时间24小时**

```yaml
# session登录态超时时间
spring:  
  session:
    timeout: 86400
```



设置常量接口

![12.png](./用户中心项目.assets/12.png)

```java
public interface UserConstant {

    /**
     *  用户登录态键
     */
    String USER_LOGIN_STATE = "userLoginState";

    /**
     * 权限
     * @Description 用户角色 0[普通用户] 1[管理员] 2[VIP]
     */
    int DEFAULT_ROLE = 0;
    int ADMIN_ROLE = 1;
    int VIP_ROLE = 2;
}
```

**这里之前的常量用户登录态的部分都改为导入这里的常量。**



**书写查询用户和删除用户的接口。**

```java
    @GetMapping("/search")
    public List<User> getUserList(String userName, HttpServletRequest request) {
        // 鉴权 仅管理员可以查询
        if (!isAdmin(request)) return new ArrayList<>();
        // 查询 为空则查所有用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (!StringUtils.isBlank(userName)) {
            queryWrapper.like("user_name", userName);
        }
        List<User> userList = userService.list(queryWrapper);
        // 数据脱敏
        return userList.stream().map(userService::getSafetyUser).collect(Collectors.toList());
    }

    @PostMapping("/delete")
    public boolean deleteUser(@RequestBody long id, HttpServletRequest request) {
        // 鉴权 仅管理员可以查询
        if (!isAdmin(request)) return false;
        return userService.removeById(id);
    }
```



# 三. 前端登录注册

1. 精简界面
2. 删除不要的代码



正向代理：替客户端向服务器发送请求，可以解决跨域问题

反向代理：替服务器统一接收请求。

怎么实现代理？

Nginx 服务器 

Node.js 服务器



**举例**

原本请求：http://localhost:8000/api/user/login

代理到请求：http://localhost:8080/api/user/login

<img src="./用户中心项目.assets/13.png" alt="13.png" style="zoom: 50%;" />

## 0. 前端请求库及封装关系

前端需要向后端发送请求才能获取数据 / 执行操作。

怎么发请求：前端使用 ajax 来请求后端

`axios` 封装了 ajax

`request` 是 `ant design` 项目又封装了一次

![24.png](./用户中心项目.assets/24.png)



追踪 `request` 源码：用到了 `umi` 的插件、`requestConfig` 配置文件

**其实可以从 `app.tsx` 这里写好全局代理访问的前缀路径，让我们前端项目发送请求都发送给对应的后端域名 **

<img src="./用户中心项目.assets/25.png" alt="25.png" style="zoom:80%;" />



## 1. 初步精简

**以 `dev` 模式直接运行**

![14.png](./用户中心项目.assets/14.png)



**这里可以定义一个常量区域，存一些公共的常量，比如 `github` 地址，或者是 `b站地址`。然后可以导入到别的组件里面，直接引用，比如 `Footer` 。**

<img src="./用户中心项目.assets/15.png" alt="15.png" style="zoom:67%;" />



首先我们得找到开发登录页面在哪，先去 `config/routes.ts` 找路由

![50.png](./用户中心项目.assets/50.png)



发现它的位置，然后去改动，下面两个是多余文件删除

<img src="./用户中心项目.assets/51.png" alt="51.png" style="zoom: 80%;" />



这里发现 `index.tsx` 的 `<Lang />` 爆红， `ctrl + 左键` 进来，这里都没用到，直接删除，然后把 `<Lang />` 也删除。

然后可以编辑 `subTitle` ，写一个自己的 `Title`。

也可以通过 react 语法 写一个超链接，链接到自己想要跳转的网页，如自己的博客。

```js
subTitle={
    <a href="xxxxx" target="_blank">
    	这是我的博客
    </a>
}
```



**这里快速的删除修改一下登录页面。删除其他登录方式。**

![](./用户中心项目.assets/16.png)

<img src="./用户中心项目.assets/17.png" alt="17.png" style="zoom: 67%;" />

<img src="./用户中心项目.assets/18.png" alt="18.png" style="zoom:67%;" />



更改登录的 `placeholder` 基础 html 学过的东西。

<img src="./用户中心项目.assets/19.png" alt="19.png" style="zoom:50%;" />

![20.png](./用户中心项目.assets/20.png)

<img src="./用户中心项目.assets/21.png" alt="21.png" style="zoom:67%;" />



这里使用 `shift + F6` 直接重构比较保险

<img src="./用户中心项目.assets/22.png" alt="22.png" style="zoom:67%;" />



**这里相当于踩坑了，这里改的是 `ts` 只是对前端写代码的一个规范，事实上发给后端的请求里面的请求体里面的表单字段名称还是得在表单的 `name` 属性去修改。**

<img src="./用户中心项目.assets/26.png" alt="26.png" style="zoom:67%;" />



**这里顺便还可以看一下官方文档关于登录表单的规则，试着给前端加一些新的规则限制。**

![27.png](./用户中心项目.assets/27.png)

<img src="./用户中心项目.assets/28.png" alt="28.png" style="zoom:67%;" />

```yaml
server:
  address: 0.0.0.0
  port: 8080
```

**`spring boot` 部署服务器端微服务，`server.address` 配置 `0.0.0.0`**

**需要在 `application.properties` 配置 `server.address=0.0.0.0`**

**否则当微服务的jar部署在机器上跑起来后，外面机器通过http连接访问不到。**



## 2. 注册页面的开发

**注册页完全可以复用登录页面，同时我们肯定也要添加相关的路由，这里我们就先复制组件，然后更改注册页面的组件。**

![34.png](./用户中心项目.assets/34.png)



**同时这里复用的页面我们要记住，不能组件名还一样，要不然重构的时候容易把它也给重构了，这里只改组件名和 `export` 出去的组件名，变量名我们就先不改了。**

<img src="./用户中心项目.assets/35.png" alt="35.png" style="zoom:67%;" />



**改详细的注册组件之前，我们先改一下我们的路由，照着登录抄一个嵌套路由即可【不懂路由的建议学一下 react 入门】**

![36.png](./用户中心项目.assets/36.png)



**这里测试看看能不能进去这个页面，输入 `url` ，发现即便是把注册页面的所有带逻辑的部分都注释都过不来，说明肯定前端部分有拦截器，让我们没登录的情况下，重定向回登录页面。**

![37.png](./用户中心项目.assets/37.png)



**下面的方法也写了重定向的逻辑**

![38.png](./用户中心项目.assets/38.png)



<font color='red'>**它控制了页面的跳转，如果没有登录，就强制我们去登录页面，但是作为一个后台管理系统，说得过去，因为必须得是能登录的人才能访问，但是对于我们一个面向前端可以开发的页面，肯定不太合适【总不能没法登录吧】，这里就优化一下逻辑，可以以数组的形式，给一个白名单，目前暂时定为【登录页面和注册页面】**</font>

```jsx
    onPageChange: () => {
      const { location } = history;
      const whiteList = ['/user/register', loginPath];
      if (whiteList.includes(location.pathname)) {
        return;
      }
      // 如果没登录，重定向到 login
      if (!initialState?.currentUser) {
        history.push(loginPath);
      }
```



**同时把上面的获取登录信息部分的重定向也先注释掉，测试发现可以完成走到这个页面了**

<img src="./用户中心项目.assets/52.png" alt="52.png" style="zoom: 33%;" />



**由以上可总结**

**Ant Design Pro（`Umi` 框架）权限管理**

`app.tsx`：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）

`access.ts` 控制用户的访问权限

获取初始状态流程：首次访问页面（刷新页面），进入 `app.tsx`，执行 `getInitialState` 方法，该方法的返回

值就是全局可用的状态值。



**然后我们来先把注册页面的部分逻辑给它写清楚，首先是注册肯定没登录，获取用户登录信息的方法就没必要留了，删了。**

<img src="./用户中心项目.assets/53.png" alt="53.png" style="zoom:50%;" />



**然后复制一个密码的表单项，记得 【账号，密码，确认密码】 都需要把 `name` 对应我们后端封装的请求体类的属性名称【`userAccount`，`userPassword`，`checkPassword`】**

**自动登录和忘记密码就不需要留了，直接删除即可。全局把 【登录】 两个字在当前页面换成【注册】**

**<font color='red'>这里指点一下，前端后端都应该有校验，前端的校验是给用户用的，但是防不了小人，别人可以绕开前端访问后端</font>**



这里可以通过定位 `LoginForm` 表单的源码，然后左边找到源码对应的文件，发现和它在一起的 `js` 文件里面有内部的一些没封装给我们让我们曝光选择修改的 `submitText`【登录】，我们按照它的格式改成注册

```jsx
          submitter={{
            searchConfig: {
              submitText: '注册',
            },
          }}
```



**这里和登录相同，提交表单都是执行了这个方法，而这里提交的参数作为 登录参数，我们应该跟着登录参数照着修改一个自己的注册参数**

```jsx
          onFinish={async (values) => {
            await handleSubmit(values as API.LoginParams);
          }}
```

<img src="./用户中心项目.assets/54.png" alt="54.png" style="zoom:50%;" />

**然后给注册的页面全局替换成我们新写的**



接着重写 `handleSubmit` 的逻辑，我们的表单已经限制了一些逻辑，比如长度大于8，非空，我们可以添加一些，减轻后端压力。



**下面的代码已经跑通了，这里我调用的是我后端根据 `swagger3` 生成的前端接口，可以看我下一节部分，讲解如何直接生成，就不用自己写了。跨域的坑我也踩了，后面写了解决办法。**

```jsx
const Register: React.FC = () => {
  const [type, setType] = useState<string>('account');
  const containerClassName = useEmotionCss(() => {
    return {
      display: 'flex',
      flexDirection: 'column',
      height: '100vh',
      overflow: 'auto',
      backgroundImage:
        "url('https://img1.baidu.com/it/u=758041072,4143042590&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800')",
      backgroundSize: '100% 100%',
    };
  });

  const handleSubmit = async (values: API.RegisterParams) => {
    const { userPassword, checkPassword } = values;
    // 校验
    if (userPassword !== checkPassword) {
      message.error('两次输入的密码不一致,请重试');
      return;
    }

    try {
      // 注册
      // 消息设置属性名 id 【后端设置为返回主键 id】
      const id = await userRegisterUsingPOST(values);
      // 未来封装 返回体为 包装类 数据封装在 data 状态码封装在 code 这里我记得后端是返回的0【登录成功】
      if (id === 0) {
        const defaultLoginSuccessMessage = '注册成功！';
        message.success(defaultLoginSuccessMessage);

        // 跳转回登录页面
        const urlParams = new URL(window.location.href).searchParams;
        history.push(urlParams.get('redirect') || '/');
        return;
      } else {
        // 下面既然会捕获异常，我们就抛出去让它处理即可
        throw new Error(`register error id = ${id}`);
      }
    } catch (error) {
      const defaultLoginFailureMessage = '注册失败，请重试！';
      console.log(error);
      message.error(defaultLoginFailureMessage);
    }
  };

  return (
    <div className={containerClassName}>
      <Helmet>
        <title>
          {'注册'}- {Settings.title}
        </title>
      </Helmet>
      <div
        style={{
          flex: '1',
          padding: '32px 0',
        }}
      >
        <LoginForm
          submitter={{
            searchConfig: {
              submitText: '注册',
            },
          }}
          contentStyle={{
            minWidth: 280,
            maxWidth: '75vw',
          }}
          logo={<img alt="logo" src="/logo.svg" />}
          title="XY の 后台管理系统"
          subTitle={<h3>XY の 后台管理系统 是 FANXY 开发的简单的后台脚手架管理系统</h3>}
          initialValues={{
            autoLogin: true,
          }}
          onFinish={async (values) => {
            await handleSubmit(values as API.RegisterParams);
          }}
        >
          <Tabs
            activeKey={type}
            onChange={setType}
            centered
            items={[
              {
                key: 'account',
                label: '账号密码注册',
              },
            ]}
          />

          {type === 'account' && (
            <>
              <ProFormText
                name="userAccount"
                fieldProps={{
                  size: 'large',
                  prefix: <UserOutlined />,
                }}
                placeholder={'旅行者,这是你输入账号的地方'}
                rules={[
                  {
                    required: true,
                    message: '账号不填可是注册不了的喔！',
                  },
                ]}
              />
              <ProFormText.Password
                name="userPassword"
                fieldProps={{
                  size: 'large',
                  prefix: <LockOutlined />,
                }}
                placeholder={'这是你输入密码的地方'}
                rules={[
                  {
                    required: true,
                    message: '密码不填可是注册不了的喔！',
                  },
                  {
                    type: 'string',
                    min: 8,
                    message: '密码不够8位，太短啦',
                  },
                ]}
              />
              <ProFormText.Password
                name="checkPassword"
                fieldProps={{
                  size: 'large',
                  prefix: <LockOutlined />,
                }}
                placeholder={'请再次输入你的密码'}
                rules={[
                  {
                    required: true,
                    message: '确认密码不填可是注册不了的喔！',
                  },
                  {
                    type: 'string',
                    min: 8,
                    message: '确认密码不够8位，太短啦',
                  },
                ]}
              />
            </>
          )}
        </LoginForm>
      </div>
      <Footer />
    </div>
  );
};
export default Register;
```



## 3. 整合 knife4j 生成前后端调用代码

**这里插播一下，自己写前后端对应的方法和类型，然后属性字段，实在是太麻烦了，这里我直接引入 `swagger2` 和 `knife4j` 然后直接通过接口文档来给我们的项目生成接口文档，前端那边可以直接根据地址和 `OpenApi` 规范对应也生成对应的方法。**

**首先是依赖**

```xml
        <!-- https://doc.xiaominfo.com/knife4j/documentation/get_start.html-->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-spring-boot-starter</artifactId>
            <version>3.0.3</version>
        </dependency>
```



**配置**

```yaml
# 公共配置文件
spring:
  application:
    name: xy-usercenter
  # 默认 dev 环境
  profiles:
    active: dev
  # 支持 swagger3
  mvc:
    pathmatch:
      matching-strategy: ant_path_matcher
```



**然后是对应的配置类，填写对应的项目名称，扫描包名**

```java
@Configuration
@EnableSwagger2
@Profile({"dev", "test"})
public class Knife4jConfig {

    @Bean
    public Docket defaultApi2() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(new ApiInfoBuilder()
                        .title("接口文档")
                        .description("xy-usercenter")
                        .version("1.0")
                        .build())
                .select()
                // 指定 Controller 扫描包路径
          .apis(RequestHandlerSelectors.basePackage("com.fanxy.xyusercenter.controller"))
                .paths(PathSelectors.any())
                .build();
    }
}
```



**当然，使用前先启动一下，进入 `api` 接口网页，测试一下注册和登录功能是否正常**

```sh
http://localhost:8080/doc.html
```

**而我们传给前端框架的是 `ant design` 框架，根据后端代码提供的 `api` 接口，可以自动一键生成前端页面的配置**

```sh
http://localhost:8080/v2/api-docs
```



**前端这里要在 `config.ts` 把对应的配置写好，方便一键生成。**

![29.png](./用户中心项目.assets/29.png)

**然后根据 `openapi` 规则，生成前端 Service 代码**

![30.png](./用户中心项目.assets/30.png)

**此时前端部分已经生成了和我们 `UserController` 对应的方法**

![31.png](./用户中心项目.assets/31.png)



**<font color='red'>注意:前端须更改对应的请求地址为你的后端地址，方法:在`app.tsx`里修改`request.baseURL`，记得一定要大写，不大写无法跑通</font>**

![32.png](./用户中心项目.assets/32.png)

现在登录其实会返回 404，因为我们虽然生成了关于 **后端** 的接口，但是其实脚手架里面的很多代码还没改成对应接口的样子，比如这里的 404 肯定是因为登录的请求地址都不是我们的后端。



执行登录会执行下面的函数，我们可进去看看这个函数干了什么，**先把 API 改成我们自己的登录的 `API.UserLoginRequest`**

![60.png](./用户中心项目.assets/60.png)

然后就是开始改写这个函数的登录逻辑了

![61.png](./用户中心项目.assets/61.png)



**<font color='red'>更改后如下 【这里还没封装返回体（就只能暂时登录逻辑为 res.id !== null，同时如果失败返回一个弹窗）】</font>**

```jsx
  const handleSubmit = async (values: API.UserLoginRequest) => {
    try {
      // 登录
      // 改 userLoginUsingPost
      // 多余类型删除
      // 消息设置属性名 res
      const res = await userLoginUsingPOST(values);
      // 未来封装 返回体为 包装类 数据封装在 data 状态码封装在 code
      if (res.id !== null) {
        const defaultLoginSuccessMessage = '登录成功！';
        message.success(defaultLoginSuccessMessage);
        // 获取登录信息 这个函数需要改
        await fetchUserInfo();
        // 跳转回登录页面
        const urlParams = new URL(window.location.href).searchParams;
        history.push(urlParams.get('redirect') || '/');
        return;
      } else {
        // 这个未来返回封装的后端的返回体的 message 信息
        message.error('登录失败，请重试！');
      }
    } catch (error) {
      const defaultLoginFailureMessage = '登录失败，请重试！';
      console.log(error);
      message.error(defaultLoginFailureMessage);
    }
  };
```



**登录还是失败，这里在浏览器看了下，莫名其妙带了 `token` ，应该是跨域的问题，我们遇到了这个跨域错误，为什么会跨域?因为我们当前前端的浏览器里的地址，它是8000端口，但是我们的后端，它是8080端口，端口不一样，就是跨域的。跨域的话，有很多种方式解决，要么搭一个代理，要么在你的后端去支持跨域，但后端支持跨域很不安全。**

![33.png](./用户中心项目.assets/33.png)



`Ant Design Pro` 它提供了一个配置代理的方式，我们直接用它的代理即可

![56.png](./用户中心项目.assets/56.png)



**默认 `ant design pro` 这个好像自带 `api` 的前缀，我改成 `\` 直接报错，后端只能也加上，然后用它的代理。 重新生成一下后端的接口文档，前端对应生成对应的地址传过去生成接口方法。**

```yaml
server:
  address: 0.0.0.0
  port: 8080
  servlet:
    context-path: /api
```

**当然，使用前先启动一下，进入 `api` 接口网页，测试一下注册和登录功能是否正常**

```sh
http://localhost:8080/api/doc.html
```

**而我们传给前端框架的是 `ant design` 框架，根据后端代码提供的 `api` 接口，可以自动一键生成前端页面的配置**

```sh
http://localhost:8080/api/v2/api-docs
```



**这里走它的代理，我们删了配置的 `baseURL` 这一行才能走它的代理。**

![55.png](./用户中心项目.assets/55.png)



**此时彻底解决跨域问题，可以专心开发了，可以显示登录成功，然后还能返回数据，和我们后端设置的完全相同，注册部分也是，照着我的方式改一下，注册也可以直接成功，而且注册成功会自动跳转到登录页面，非常方便**

![57.png](./用户中心项目.assets/57.png)



**这里给登录页的组件设置一下注册地址，使用 `React`  的 `Link` 同时前端这里使用了 官网给的分隔组件和按钮组件。**

```jsx
 <div
            style={{
              marginBottom: 24,
            }}
          >
            <Space size="small" align="baseline" style={{ display: 'flex' }}>
              <ProFormCheckbox noStyle name="autoLogin">
                自动登录
              </ProFormCheckbox>

              <Button>
                <Link key="register" to="/user/register">
                  注册账号
                </Link>
              </Button>

              <Button danger>
                <a href={MY_BLOG_URL} target="_blank" rel="noreferrer">
                  忘记密码请留言
                </a>
              </Button>
            </Space>
          </div>
```

**我是搞后端的，前端菜就别吐槽俺了。**

<img src="./用户中心项目.assets/58.png" alt="58.png" style="zoom:50%;" />



# 四. 前后端小优化+后端管理

## 1. 获取当前用户的Controller方法

这里最好还是 **通过数据库查询一下比较好** ，因为很多时候是希望能实时获取最新的状态，不能用户充值了，但是刷新发现自己的账户没有增加余额。

```java
    /**
     * 获取当前用户信息
     *
     * @param request 当前请求
     * @return 脱敏的当前用户信息
     */
    @GetMapping("/current")
    public User getCurrentUser(HttpServletRequest request) {
        // 获取登录态
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser = (User) userObj;
        if (currentUser == null) {
            return null;
        }
        // 根据id获取用户信息 通过数据库查询
        long userId = currentUser.getId();
        // todo 校验用户是否合法
        User user = userService.getById(userId);
        return userService.getSafetyUser(user);
    }
```



## 2. 获取登录态的前端修改【实现登录】

相应，我们终于能更新前端部分，获取当前用户信息的方法，以及保存全局用户登录态的部分。

![62.png](./用户中心项目.assets/62.png)



**这里继续优化 `app.tsx` 的登录相关的，获取登录状态的方法，这里 `三.2. 注册页面的开发` 部分封装的白名单可以提到最上面，作为全局的一个常量，直接调用，将来增加页面直接在上面增加即可。**

![63.png](./用户中心项目.assets/63.png)



同时有些字段没必要返回给前端，存在信息泄露

<img src="./用户中心项目.assets/64.png" alt="64.png" style="zoom:67%;" />

**这里进行一波大修改 `app.tsx` 获取登录态的内容**

<img src="./用户中心项目.assets/65.png" alt="65.png" style="zoom:67%;" />



**日后可以进一步像它一样，封装自己的返回体，把数据放在 data 里面，然后前端这里靠状态码和返回消息来得知如何处理逻辑**

```jsx
export async function getInitialState(): Promise<{
  // 当前用户 我们改成我们后端自己写的获取登录态的接口
  currentUser?: API.User;
}> {
  const fetchUserInfo = async () => {
    try {
      // 改成后端生成的 User 类 这里页不需要传任何参数
      const user = await getCurrentUserUsingGET({});
      return user;
    } catch (error) {
      history.push(loginPath);
    }
    return undefined;
  };
  // 如果不是登录页面 执行 【改成如果不在无需登录态的页面】
  const { location } = history;
  if (!NO_NEED_LOGIN_WHITE_LIST.includes(location.pathname)) {
    const currentUser = await fetchUserInfo();
    return {
      // 这里返回部分我们只返回我们自己写的信息
      currentUser,
    };
  }
  // 如果不是登录状态就不返回当前用户信息即可
  return {};
}

```



**同时我们登录页面会使用这个方法，获取登录态，所以我们这里要相应让两边方法对接一下。**

<img src="./用户中心项目.assets/66.png" alt="66.png" style="zoom: 80%;" />

```jsx
  const fetchUserInfo = async () => {
    // 登录页面对接刚刚设置好的获取登录态方法
    const userInfo = await getCurrentUserUsingGET();
    if (userInfo) {
      flushSync(() => {
        setInitialState((s) => ({
          ...s,
          currentUser: userInfo,
        }));
      });
    }
  };
```



**此时登录，完美进入页面，但是头像狂转，而且菜单栏也没显示完全。**

<img src="./用户中心项目.assets/67.png" alt="67.png" style="zoom:33%;" />



**这里关于没有菜单是因为路由新版没有写名字，自己可以对应功能写好就会显示**

<img src="./用户中心项目.assets/68.png" alt="68.png" style="zoom:50%;" />



**我们就根据自己的字段写一下，但是发现头像有了，但是还是有东西转**

<img src="./用户中心项目.assets/69.png" alt="69.png" style="zoom:67%;" />



**通过对 `avatar` 进行搜索，发现有个设置叫作 `RightContent` 的组件 有对`AvatarDropdown.tsx` 和 `index.tsx`，这个一定就是内容栏的设置，比如显示头像，进去可以看到字段应该填我们的用户有的字段，我们设置的名字字段和系统默认的不一样，需要改成我们的。**

**而 `HeaderDropdown` 组件一定就是和头像下拉栏相关的组件，也就是头像转圈的罪魁祸首，我们这里把它改成我们实际的字段名称，刷新页面。**

![70.png](./用户中心项目.assets/70.png)



## 3. 用户管理

**从 0 开始自己写一个用户管理的表单**

复制注册当时写的组件，在它的基础上我们改，和自己写注册逻辑差不多。这个管理功能应该是仅管理员可用，所以我们新建一个文件夹 `admin` 把管理员相关的组件放进去，我们在 `page` 文件夹创建 `Admin` 文件夹，然后创建 `UserManage`。【仅作测试看看能不能显示画面，能的话，就删了 `index.tsx` 的内容，自己写表单】

同时给它写一个对应的管理员的子路由，抄路由部分别的代码即可，组件填我们自己的。二级管理页面返回的还是管理员首页。【应该是为了展示如何定义二级页面，想删可以删除】

<img src="./用户中心项目.assets/72.png" alt="72.png" style="zoom:67%;" />



这里能看到，关于 `/admin` 的路由是需要一个 `access` 即权限的，这个权限其实是在 `access.tsx`  文件可以定义。

结合目前的学习，可以总结如下。

**Ant Design Pro（`Umi` 框架）权限管理**

`app.tsx`：**项目全局入口文件**，定义了整个项目中使用的公共数据（比如用户信息）

`access.ts` : **控制用户的访问权限**

获取初始状态流程：首次访问页面（刷新页面），进入 `app.tsx`，执行 `getInitialState` 方法，**该方法的返回**

**值就是全局可用的状态值。**

![73.png](./用户中心项目.assets/73.png)



**结合这个后台框架的逻辑，后面我们也可以在这定义一个，`canVIP` 定义角色属性，只有为 `vip` 的用户才能访问的权限变量，然后给路由去添加。**





**官网手册** https://procomponents.ant.design/components/form

 **`ProComponents`** **高级表格【这里用了表格不是表单，因为只是显示和管理用户而不是提交信息】**

直接复制官方的，然后改写

<img src="./用户中心项目.assets/74.png" alt="74.png" style="zoom: 33%;" />

**<font color='red'>删除冗余代码</font>工具栏这里起到了分组的作用，这里没啥用，就删了。其他同理。**

<img src="./用户中心项目.assets/76.png" alt="76.png" style="zoom: 33%;" />

<img src="./用户中心项目.assets/77.png" alt="77.png" style="zoom: 50%;" />

<img src="./用户中心项目.assets/78.png" alt="78.png" style="zoom:50%;" />



表格的数据是 定义了一个 `GithubIssueItem` ，后面通过请求从 `url` 获取的，这里我们改成自己的用户类型，然后定义列即可。



1. 通过 `columns` 定义表格有哪些列
2. `columns` 属性  

`dataIndex` 对应返回数据对象的属性

`title` 表格列名

`copyable` 是否允许复制

`ellipsis` 是否允许缩略

`valueType`：用于声明这一列的类型（`dateTime`、`select`） **【这里我们直接改成角色为枚举值的对应字段】**

请求返回的属性直接使用 `API.User`【这里是我的 `swagger` 生成的类型名】



**这里搜索就先学下面，强行查一下，可以查到，但是头像是链接，非常不好看。**

![79.png](./用户中心项目.assets/79.png)



**我们先来看看渲染的逻辑，第一个参数是当前的节点，可以理解为当前的对应一个列属性的字段，而 `record` 是相当于这一整行数据。这里第一个参数随便命名就是因为第一个参数用不到，就随便命名，我们只需要取 `record` 的对应的 `avataUrl` 字段，使用一个 `<Img >` 标签渲染即可。【这是 ant design 自带的标签，给我们封装好了，可以方便的展示图片】**

```jsx
  {
    title: '头像',
    dataIndex: 'avatarUrl',
    render: (_, record) => <Image src={record.avatarUrl} width="40" />,
  },
```



用户角色这里就使用枚举值，可以看官方文档，这部分的属性和细节的各个属性设置。然后设置可以用作筛选字段，即有一个下拉框，可以选择角色进行查询。

状态也一样设置即可。

```jsx
  {
    title: '角色',
    dataIndex: 'userRole',
    valueType: 'select',
    filters: true,
    onFilter: true,
    valueEnum: {
      0: {
        text: '普通用户',
        status: 'Default',
      },
      1: {
        text: '管理员',
        status: 'Processing',
      },
      2: {
        text: 'VIP会员',
        status: 'Success',
      },
    },
  },
```



**暂时的版本，还没有完全对接后端，只是写了个简单的方法调用。**

```jsx
import { getUserListUsingGET } from '@/services/xy-usercenter/userController';
import { PlusOutlined } from '@ant-design/icons';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import { TableDropdown } from '@ant-design/pro-table';
import { Button, Image } from 'antd';
import { useRef } from 'react';
import request from 'umi-request';
export const waitTimePromise = async (time: number = 100) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
};

export const waitTime = async (time: number = 100) => {
  await waitTimePromise(time);
};

const columns: ProColumns<API.User>[] = [
  {
    dataIndex: 'id',
    valueType: 'indexBorder',
    width: 48,
  },
  {
    title: '用户名',
    dataIndex: 'userName',
    copyable: true,
    ellipsis: true,
  },
  {
    title: '账号',
    dataIndex: 'userAccount',
    copyable: true,
    ellipsis: true,
  },
  {
    title: '性别',
    dataIndex: 'gender',
  },
  {
    title: '电话',
    dataIndex: 'phone',
    copyable: true,
    ellipsis: true,
  },
  {
    title: '头像',
    dataIndex: 'avatarUrl',
    render: (_, record) => <Image src={record.avatarUrl} width="40" />,
  },
  {
    title: '邮件',
    dataIndex: 'email',
    copyable: true,
    ellipsis: true,
  },
  {
    title: '状态',
    dataIndex: 'userStatus',
    valueType: 'select',
    filters: true,
    onFilter: true,
    valueEnum: {
      0: {
        text: '正常',
        status: 'Default',
      },
      1: {
        text: '注销',
        status: 'Warning',
      },
      2: {
        text: 'VIP会员',
        status: 'Error',
      },
    },
  },
  {
    title: '角色',
    dataIndex: 'userRole',
    valueType: 'select',
    filters: true,
    onFilter: true,
    valueEnum: {
      0: {
        text: '普通用户',
        status: 'Default',
      },
      1: {
        text: '管理员',
        status: 'Processing',
      },
      2: {
        text: 'VIP会员',
        status: 'Success',
      },
    },
  },
  {
    title: '创建时间',
    dataIndex: 'createTime',
    valueType: 'dateTime',
  },
  {
    title: '操作',
    valueType: 'option',
    key: 'option',
    render: (text, record, _, action) => [
      <a
        key="editable"
        onClick={() => {
          action?.startEditable?.(record.id);
        }}
      >
        编辑
      </a>,
      <a href={record.url} target="_blank" rel="noopener noreferrer" key="view">
        查看
      </a>,
      <TableDropdown
        key="actionGroup"
        onSelect={() => action?.reload()}
        menus={[
          { key: 'copy', name: '复制' },
          { key: 'delete', name: '删除' },
        ]}
      />,
    ],
  },
];

export default () => {
  const actionRef = useRef<ActionType>();
  return (
    <ProTable<API.User>
      columns={columns}
      actionRef={actionRef}
      cardBordered
      request={async (params = {}, sort, filter) => {
        console.log(sort, filter);
        const res = await getUserListUsingGET();
        return {
          data: res,
        };
        await waitTime(2000);

        return request<{
          data: API.User[];
        }>('http://localhost:8080/api/user/search', {
          params,
        });
      }}
      editable={{
        type: 'multiple',
      }}
      columnsState={{
        persistenceKey: 'pro-table-singe-demos',
        persistenceType: 'localStorage',
        onChange(value) {
          console.log('value: ', value);
        },
      }}
      rowKey="id"
      search={{
        labelWidth: 'auto',
      }}
      options={{
        setting: {
          listsHeight: 400,
        },
      }}
      form={{
        // 由于配置了 transform，提交的参与与定义的不同这里需要转化一下
        syncToUrl: (values, type) => {
          if (type === 'get') {
            return {
              ...values,
              created_at: [values.startTime, values.endTime],
            };
          }
          return values;
        },
      }}
      pagination={{
        pageSize: 5,
        onChange: (page) => console.log(page),
      }}
      dateFormatter="string"
      headerTitle="高级表格"
      toolBarRender={() => [
        <Button
          key="button"
          icon={<PlusOutlined />}
          onClick={() => {
            actionRef.current?.reload();
          }}
          type="primary"
        >
          新建
        </Button>,
      ]}
    />
  );
};

```



# 五. 注销/增删改【前后端优化】

## 1. 用户注销

### 1.1. 后端的注销

```java
    /**
     * 用户注销
     * @return 是否成功 1[成功] 
     */
    @Override
    public int userLogout(HttpServletRequest request) {
        request.getSession().removeAttribute(USER_LOGIN_STATE);
        return 1;
    }
```

`Controller` 方法

```java
    /**
     * 用户注销
     * @param request 用户请求
     * @return 1[成功]
     */
    @PostMapping("/logout")
    public Integer userLogout(HttpServletRequest request) {
        if (request == null) {
            return null;
        }
        return userService.userLogout(request);
    }
```



### 1.2. 前端的注销

![80.png](./用户中心项目.assets/80.png)



后端登录态在 `Session` ，而前端登录态，是通过之前说过的 `getInitialState` 保存在 `currentUser`  的。这里可以看到 **底层的做法是把登录态的 `currentUser` 给设置 `undefined` ，其他的展开保持不变**

![81.png](./用户中心项目.assets/81.png)



**这里我重新根据后端生成前端接口，然后改成调用我们生成的接口，测试发现注销前后端都失去了登录态。**

![82.png](./用户中心项目.assets/82.png)



## 2. 用户校验

> 仅适用于用户可信的情况

用户填写一个属于自己的编号：用户编号 `userCode`

后台补充对编号的校验：长度校验、唯一性校验

`UserServiceImpl` 校验唯一性

这里我的系统感觉没有对接星球编号的需要，逻辑方面无非就是增加一个字段，然后 Service ，Controller 的方法 ，前端的注册框增加。没有什么新的知识点。



## 3. 后端优化

### 3.1. 通用返回对象

目的：给对象补充一些信息，告诉前端这个请求在 **业务层面** 上是成功还是失败

200、404、500、502、503

```json
{
    "name": "fanxy"
}
// 成功
{
    "code": 0 // 业务状态码
    "data": {
        "name": "fanxy"
	},
    "message": "ok"
}
// 错误
{
    "code": 50001 // 业务状态码
    "data": null
    "message": "用户操作异常、xxx"
}
```

自定义错误码，返回类支持返回正常和错误

能够更加精准知道报错的信息

新建一个 `common` 包用来存通用的类组件，这里创建 `BaseRsponse` 和 `ReturnUtils` 

```java
public class BaseResponse<T> implements Serializable {
    private static final long serialVersionUID = 6743525284004299555L;

    private int code;
    private T data;
    private String message;

    public BaseResponse(int code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    public BaseResponse(int code, T data) {
        this(code, data, "");
    }
}
```

```java
public class ResultUtils {
    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>(0, data, "ok");
    }
}
```







### 3.2. 封装全局异常处理器

**实现**

1. 定义业务异常类
2. 相对于 java 的异常类，支持更多字段
3. 自定义构造函数，更灵活 / 快捷的设置字段
4. 编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）

**作用**

1. 捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 / 信息
2. 同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）
3. 集中处理，比如记录日志











