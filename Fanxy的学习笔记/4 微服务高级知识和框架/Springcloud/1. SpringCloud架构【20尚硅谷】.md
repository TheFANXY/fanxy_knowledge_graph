# 1. 序章及微服务架构代码构建

## 1.1. 创建工程

![1微服务技术栈介绍.png](./1. SpringCloud架构【20尚硅谷】.assets/1微服务技术栈介绍.png)

本笔记所采用软件版本，软件Cloud和Boot有适配问题，上Spring官网，可以看到Cloud对应Boot的版本对应关系。

| 软件          | 版本          |
| ------------- | ------------- |
| SpringCloud   | Hoxton.SR1    |
| SpringBoot    | 2.2.2.RELEASE |
| Cloud alibaba | 2.1.0.RELEASE |
| JAVA          | JDK8          |
| Maven         | 3.5以上       |
| Mysql         | 5.7以上       |

![image-20230715160600002](./1. SpringCloud架构【20尚硅谷】.assets/2创建父项目.png)

记得要打开注解驱动设置

![3开启注解驱动](./1. SpringCloud架构【20尚硅谷】.assets/3开启注解驱动.png)

## 1.2. Maven文件

**dependencyManagement**

Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式。
**<font color="bb000">通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。</font>**

使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。
Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个
dependencyManagement 元素中指定的版本号。

这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改 ；另外如果某个子项目需要另外的一个版本，只需要声明version就可。

*     **<font color="bb000">dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</font>**

*   **<font color="bb000">如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;</font>**
    
*     如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。

**<font color="bb000">指定跳过Maven的测试生命周期</font>**

![4跳过测试模式.png](./1. SpringCloud架构【20尚硅谷】.assets/4跳过测试模式.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.fanxy.springcloud</groupId>
    <artifactId>cloud2023</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>

  <modules>
    <module>cloud-provider-payment8001</module>
  </modules>

  <!--统一管理jar包版本-->
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <junit.version>4.12</junit.version>
    <lombok.version>1.18.10</lombok.version>
    <log4j.version>1.2.17</log4j.version>
    <mysql.version>5.1.47</mysql.version>
    <druid.version>1.1.16</druid.version>
    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>
  </properties>

  <!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version-->
  <dependencyManagement>
  <dependencies>
  <!--spring boot 2.2.2-->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.2.2.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--spring cloud Hoxton.SR1-->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>Hoxton.SR1</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--spring cloud 阿里巴巴-->
  <dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
    <version>2.1.0.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--mysql-->
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>${mysql.version}</version>
    <scope>runtime</scope>
  </dependency>
  <!-- druid-->
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>${druid.version}</version>
  </dependency>
    <!--mybatis-->
    <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>${mybatis.spring.boot.version}</version>
    </dependency>
    <!--junit-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>${junit.version}</version>
    </dependency>
    <!--log4j-->
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>${log4j.version}</version>
    </dependency>
  </dependencies>

  </dependencyManagement>
  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <version>2.5.0</version>
        <configuration>
          <fork>true</fork>
          <addResources>true</addResources>
        </configuration>
      </plugin>
    </plugins>
  </build>

</project>
```

## 1.3. 微服务提供者支付Module模块

```sh
cloud-provider-payment8001
```

### 1.3.1. 改POM文件

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.fanxy.springcloud</groupId>
        <artifactId>cloud2023</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>cloud-provider-payment8001</artifactId>
    <packaging>jar</packaging>

    <name>cloud-provider-payment8001</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>
        <!--mysql-connector-java-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!--jdbc-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 1.3.2. 写yml文件和主程序

```yml
server:
  port: 8001


spring:
  application:
    name: cloud-payment-service
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource         # 当前数据源操作类型
    driver-class-name: com.mysql.cj.jdbc.Driver              # mysql驱动包 com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:13306/db2023?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: xxxxxxxx

mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.fanxy.springcloud.entities    # 所有Entity别名类所在包
```

```java
@SpringBootApplication
public class PaymentMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8001.class, args);
    }
}
```

### 1.3.3. 业务类

#### 1. 建表SQL

**本篇强调的是Cloud，所以SQL并不复杂，就一个主键一个流水号。直接建库建表就行。**

```sql
CREATE DATABASE db2023;
USE db2023;
CREATE TABLE `payment` (
                           
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',                      
    `serial` varchar(200) DEFAULT '',                  
     PRIMARY KEY (`id`)
    
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8
```

#### 2. Entities

**订单实体类**

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Payment implements Serializable {
    private Long id;
    private String serial;
}
```

**为了前后端分离，需要把返回给前端的数据封装成一个具有Http状态码，消息，以及包装传递数据的类。这里有可能我们的数据为Null，就还要写一个两个参数的构造器**

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResult<T> {

    private Integer code;
    private String message;
    private T data;

    public CommonResult(Integer code, String message) {
        this(code, message, null);
    }
}
```

#### 3. Mapper

**这里更推荐使用`@Mapper`是`Java apache`下的注解，而使用`@Repository`更多是注解在实现类，即以前不用`Mybatis`的时候。<font color="bb000">更简单的：雷神在`Springboot`教过，直接在启动类注解`@MapperScan(baseOacjages = "com.xx.xx")`即可。可能会爆红在注入的时候，因为`IDEA`不知道把对应的`mapper`注入了，无需理会</font>**

```java
@Mapper                       
public interface PaymentMapper {

    public int create(Payment payment);

    public Payment getPaymentById(@Param("id") Long id);
}
```

**这里`mapper`的`xml`，我这里使用`mybatis-x`插件一键生成，然后一定要遵循规范，尽量查询的返回类型使用`ResultMap`而不是实体类型，因为未必每个人都会遵循命名规范。**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.fanxy.springcloud.mapper.PaymentMapper">

    <!--public int create(Payment payment);-->
    <insert id="create" parameterType="payment" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO payment (serial) VALUES (#{serial})
    </insert>

    <!-- public Payment getPaymentById(@Param("id") Long id);-->
    <resultMap id="BaseResultMap" type="com.fanxy.springcloud.entities.Payment">
        <id column="id" property="id" jdbcType="BIGINT"/>
        <result column="serial" property="serial" jdbcType="VARCHAR"/>
    </resultMap>
    <select id="getPaymentById" parameterType="long" resultMap="BaseResultMap">
        SELECT id, serial FROM payment WHERE id = #{id}
    </select>

</mapper>
```

#### 4. Service

**接口类**

```java
public interface PaymentService {
    public int create(Payment payment);
    public Payment getPaymentById(Long id);
}
```

**实现类**

```java
@Service
public class PaymentServiceImpl implements PaymentService {

    @Autowired
    private PaymentMapper paymentMapper;

    public int create(Payment payment){
        return paymentMapper.create(payment);
    }

    public Payment getPaymentById(Long id){
        return paymentMapper.getPaymentById(id);
    }
}
```

#### 5. Controller

```java
@RestController
@Slf4j
public class PaymentController {

    @Autowired
    private PaymentService paymentService;

    @PostMapping("/payment/create")
    public CommonResult create(Payment payment) {
        int result = paymentService.create(payment);
        log.info("*********插入结果: " + result);

        if (result > 0) {
            return new CommonResult(200, "插入数据库成功", result);
        } else {
            return new CommonResult(444, "插入数据库失败", null);
        }
    }

    @GetMapping("/payment/get/{id}")
    public CommonResult getPaymentById(@PathVariable("id") Long id) {
        Payment payment = paymentService.getPaymentById(id);
        log.info("*********插入结果: " + payment);

        if (payment != null) {
            return new CommonResult(200, "查询成功", payment);
        } else {
            return new CommonResult(444, "查询失败,没有对应的id:" + id, null);
        }
    }
}
```

### 1.3.4. 总结

利用`PostMan`测试，发现可以正常插入数据，并且查询到数据，此时第一个模块完成。

整个微服务的模块开发流程

1. 建module
2. 改Pom
3. 写YML
4. 主启动
5. 业务类

### 1.3.5. <font color="bb000">开启Run DshBoard</font>

在左下角的服务，点击添加`Springboot`服务，即可自动导入并显示

![5Rundashboard.png](./1. SpringCloud架构【20尚硅谷】.assets/5Rundashboard.png)

## 1.4. 微服务消费者订单Module模块

```sh
cloud-consumer-order80
```

### 1.4.1. 改POM文件

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.fanxy.springcloud</groupId>
        <artifactId>cloud2023</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>cloud-consumer-order80</artifactId>
    <packaging>jar</packaging>

    <name>cloud-consumer-order80</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 1.4.2. 写yml文件和主程序

```yaml
server:
  port: 80
```

```java
@SpringBootApplication
public class OrderMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderMain80.class, args);
    }
}
```

### 1.4.3. RestTemplate和业务类

作为80端口即门面，我们理应不存在`Service`能对底层数据库进行操作的能力，故这里应该只存在`Controller`，那我们该如何调用提供者的模块呢？

**`RestTemplate`提供了多种便捷访问远程`Http`服务的方法**
**是一种简单便捷的访问`restful`服务模板类，是`Spring`提供的用于访问`Rest`服务的<font color="bb000">客户端模板工具集</font>**

官网地址  https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html
**使用`restTemplate`访问`restful`接口非常的简单粗暴无脑。有三个参数：**
**`(url, requestMap, ResponseBean.class)`**

**`REST`请求地址、请求参数、`HTTP`响应转换被转换成的对象类型。**

通过配置类给容器注入

```java
@Configuration
public class ApplicationContextConfig {
    
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

 写好`Controller`这里为了区分度，也能更好地明白关系，将80这里声明为`consumer`

```java
@RestController
@Slf4j
public class OrderController {

    public static final String PAYMENT_URL = "http://localhost:8001";

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/consumer/payment/create")
    public CommonResult<Payment> create(Payment payment){
        return restTemplate.postForObject(PAYMENT_URL + "/payment/create", payment, CommonResult.class);
    }

    @GetMapping("/consumer/payment/get/{id}")
    public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id){
        return restTemplate.getForObject(PAYMENT_URL + "/payment/get/" + id, CommonResult.class);
    }
}
```

此时同时启动两个微服务，直接浏览器通过访问消费者的链接，发现可以完成微服务的互相访问

**<font color='bb000'>但是！通过消费者创建消费者，数据库有主键，但是没有数据，是`NULL`。这是因为跨服务访问，需要在我们的`8001`服务的请求加`@RequstBody`，它可以获取请求体，需要在控制器方法设置一个形参，使用`@RequestBody`进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。`@RequsetBody` 的请求参数是转化为JSON字符串形式，而通过`RestTemplate`传过来的是json数据</font>**

## 1.5. 工程重构

**我们发现无论是前后端交互的实体类，还是订单类，这种实体类如果在每个微服务模块都去写，实在是太冗余，所以我们需要重构一下我们的代码。** 

### 1.5.1. 建立模块 + POM文件

```sh
cloud-api-commons
```

这里导入了`hutool` 工具包，后续会详细进行讲解，可以很方便完成很多操作如时间。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.fanxy.springcloud</groupId>
        <artifactId>cloud2023</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>cloud-api-common</artifactId>
    <packaging>jar</packaging>

    <name>cloud-api-common</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.1.0</version>
        </dependency>
    </dependencies>

</project>
```

### 1.5.2 实体类转移

<img src="./1. SpringCloud架构【20尚硅谷】.assets/6对Maven进行clean.png" alt="6对Maven进行clean.png" style="zoom: 80%;" />

**将其他两个模块的实体类的包和类转移过来，然后把他们的进行删除，然后我们对`Maven`进行`clean`操作，然后进行`install`，然后对另外两个模块进行`Maven`引入**

```xml
        <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
```

# 2. Eureka服务注册与发现

## 2.1. Eureka基础知识

### 2.1.1. 什么是服务治理

`Spring Cloud` 封装了 `Netflix` 公司开发的 `Eureka` 模块来实现<font color="bb000">服务治理</font>

在传统的`rpc`远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。

### 2.1.2. 什么是服务注册

Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持**心跳连接**。这样系统的维护人员就可以通过 `Eureka Server` 来监控系统中各个微服务是否正常运行。

**在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址)**

![7Eurekah和Dubbo.png](./1. SpringCloud架构【20尚硅谷】.assets/7Eurekah和Dubbo.png)

### 2.1.3. Eureka两组件

**<font color="000bb">Eureka包含两个组件：Eureka Server和Eureka Client</font>**

**<font color="bb000">`Eureka Server`</font>提供服务注册服务**
**各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。**

**<font color="bb000">`EurekaClient`</font>通过注册中心进行访问**
**是一个`Java`客户端，用于简化`Eureka Server`的交互，客户端同时也具备一个内置的、使用轮询(`round-robin`)负载算法的负载均衡器。在应用启动后，将会向`Eureka Server`发送心跳(默认周期为`30`秒)。如果`Eureka Server`在多个心跳周期内没有接收到某个节点的心跳，`EurekaServer`将会从服务注册表中把这个服务节点移除（默认`90`秒）**

## 2.2. 单机Eureka构建步骤

此时我们的之前的代码构建，80作为消费者，8001作为服务提供者，是直接调用的，现在我们将要通过`Eureka`，端口号7001添加服务注册和服务发现。

### 2.2.1. 将cloud-eureka-server7001注册为EurekaServer

#### 1. 建立模块改POM

```sh
cloud-eureka-server7001
```

```xml
以前的老版本（当前使用2018）
<dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```

```xml
现在新版本（当前使用2020.2）
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.fanxy.springcloud</groupId>
        <artifactId>cloud2023</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>cloud-eureka-server7001</artifactId>
    <packaging>jar</packaging>

    <name>cloud-eureka-server7001</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!--eureka-server-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <!--boot web actuator-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--一般通用配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>
    </dependencies>

</project>
```

#### 2. 建立yaml

**配置文件这里写明不向注册中心注册自己，而url通过上面的配置进行拼接**

```yaml
server:
  port: 7001

eureka:
  instance:
    hostname: localhost #eureka服务端的实例名称
  client:
    #false表示不向注册中心注册自己。
    register-with-eureka: false
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-registry: false
    service-url:
      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

#### 3. 主启动 @EnableEurekaServer

这里由于`7001`是`EurekaServer`端，故需要在主启动写明注解配置

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaMain7001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaMain7001.class, args);
    }
}
```

**此时启动主程序，即可直接通过对应的`ip:7001`通过浏览器访问到`Eureka`的网页控制端。**

![8Eureka网页端.png](./1. SpringCloud架构【20尚硅谷】.assets/8Eureka网页端.png)

### 2.2.2. 将cloud-provider-payment8001注册入Eureka成为服务提供者

#### 1. 改POM

**把对应的`client`的`maven`配置文件导入`8001`模块**

```xml
以前老版本 别再使用
<dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>

现在新版本 当前使用
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

#### 2. 改yaml

**微服务的名称记得不要随便改，因为我们注册会把这个名称注册到Eureka的服务端，然后加入eureka的client端的配置，然后主启动的主程序加上 `@EnaleEurekaClient`主解，完成注册的配置**

```yaml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
```

**此时我们先启动`7001`的情况下，如果启动`8001`，在我们之前的网页端就能看到它被注册进来了。名称就是我们之前定义的`application-name`，而`status`可以看到实例的主机和模块名称和端口号**

![9注册.png](./1. SpringCloud架构【20尚硅谷】.assets/9注册.png)

### 2.2.3. 将cloud-consumer-order80注册入Eureka成为服务消费者

#### 1. 改POM

**把对应的`client`的`maven`配置文件导入`80`模块**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

#### 2. 改yaml

**微服务的名称记得不要随便改，因为我们注册会把这个名称注册到Eureka的服务端，然后加入eureka的client端的配置，然后主启动的主程序加上 `@EnaleEurekaClient`主解，完成注册的配置**

```yaml
spring:
    application:
        name: cloud-order-service

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
```

**红色字体是Eureka的自我保护机制，不用理会** 

![10消费者注册.png](./1. SpringCloud架构【20尚硅谷】.assets/10消费者注册.png)

## 2.3. 集群Eureka构建步骤

### 2.3.1. Eureka集群原理说明

![11Eruka集群原理.png](./1. SpringCloud架构【20尚硅谷】.assets/11Eruka集群原理.png)

`Eureka Server`集群的每个都会互相记录互相注册，并互相守望。

### 2.3.2. Eureka集群模块搭建

#### 1. 模块搭建

```sh
cloud-eureka-server7002
```

**pom文件和`7001`完全相同，而主程序名称就是`EurekaMain7002`，和`7001`一样需要添加`@SpringbootAppilicationContext`配置类注解，和`@EnableEurekaServer`。**

**而配置文件显然我们无法和之前一样，因为我们之前直接使用`localhost`，现在虽然端口号不同，但是无法体现出是两台机器，这里就修改host文件，添加本机的ip域名映射**

```sh
127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com
```

**而配置文件我们为了完成相互守望，需要把`service-url`更改为对方的，如果是三台及其以上就添加即可。使用逗号分割，下面是7002机器的配置文件，7001对称修改即可**

```yaml
server:
  port: 7002

eureka:
  instance:
    hostname: eureka7002.com #eureka服务端的实例名称
  client:
    #false表示不向注册中心注册自己。
    register-with-eureka: false
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-registry: false
    service-url:
      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      defaultZone: http://eureka7001.com:7001/eureka/
```

#### 2. 将消费者80和生产者8001配置入集群

**两个都更改`yaml`配置文件，主要是yaml配置文件的`eureka` 的`url`同时填写相应全部的`url`，其他不需要改变**

```yaml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```

此时按顺序启动`7001/7002`，`8001`，`80`，完美启动。

### 2.3.3. 订单服务的集群搭建

#### 1. 模块搭建【复制部分】

```sh
cloud-provider-payment8002
```

**`pom`文件应该和`8001`没有区别，主程序也是把名称换成`8002`，其他的包和mapper文件全部复制过来，而`yaml`配置文件把端口号改为`8002`即可。而微服务名称都保持一致，不需要更改**

#### 2. 修改Controller【变化部分】

**虽然我们配置文件部分两个都是一个微服务的名称，但是端口号不同，我们也不知道到底后台调用了哪个，甚至我们也不知道到底是否它们此时构建了负载均衡，所以我们通过`@Value`读取配置文件的值，传给前端的数据可以写出端口号，这样在前台就知道后端到底有没有成功完成集群工作**

```java
@RestController
@Slf4j
public class PaymentController {

    @Autowired
    private PaymentService paymentService;
    
    @Value("${server.port}")
    private String serverPort;
    
    @PostMapping("/payment/create")
    public CommonResult create(@RequestBody Payment payment) {
        int result = paymentService.create(payment);
        log.info("*********插入结果: " + result);

        if (result > 0) {
            return new CommonResult(200, "插入数据库成功, 端口号为: " + serverPort, result);
        } else {
            return new CommonResult(444, "插入数据库失败", null);
        }
    }

    @GetMapping("/payment/get/{id}")
    public CommonResult getPaymentById(@PathVariable("id") Long id) {
        Payment payment = paymentService.getPaymentById(id);
        log.info("*********插入结果: " + payment);

        if (payment != null) {
            return new CommonResult(200, "查询成功, 端口号为: " + serverPort, payment);
        } else {
            return new CommonResult(444, "查询失败,没有对应的id:" + id, null);
        }
    }
}
```

依次启动，从`Eureka`前台观看服务注册

![12服务器集群.png](./1. SpringCloud架构【20尚硅谷】.assets/12服务器集群.png)

**我们发现集群构建成功，单独测试不经过消费者微服务，我们选择对应的端口号，能获取对应端口号获取的消息但是当我们使用消费者微服务，调用的情况下，发现无论访问多少次，永远都是同一个端口号返回的信息。**

**这是因为我们最开始配置的时候，就在消费者微服务端写死了访问的url，我们应该修改为微服务的名称，也就是在Eureka界面看到的服务名称<font color="bb000">【大小写均可】</font>**

```java
    // public static final String PAYMENT_URL = "http://localhost:8001";
    public static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE";
```

**但是此时再调用消费者访问，发现直接保存白页，无法找到对应的主机名，这是因为我们通过消费者调用生产者，是通过RestTemplate完成的，而它在此时并不知道到底该访问哪个生产者，需要我们给配置类注入的`restTemplate`加入注解`@LoadBalanced`**

```java
@Configuration
public class ApplicationContextBean
{
    @Bean
    @LoadBalanced //使用@LoadBalanced注解赋予RestTemplate负载均衡的能力
    public RestTemplate getRestTemplate()
    {
        return new RestTemplate();
    }
}
```

进行调用消费者访问

```sh
http://localhost/consumer/payment/get/1
```

**此时发现端口号交替出现，可以访问到后端的生产者服务器，完成了轮询的负载均衡模式**

## 2.4. actuator微服务信息完善

### 2.4.1. 主机名称：服务名称修改

此前我们的界面这里有主机的名称，一般我们希望能通过点击进行跳转，而我们希望能直观看到域名，端口号，实例名称，而没有主机的名称

![13主机名.png](./1. SpringCloud架构【20尚硅谷】.assets/13主机名.png)

我们之前导入的这两个包，有了它们两个才能完成图形化界面的信息完善，第一个不必说，第二个就是图形化的包

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
```

**修改配置文件加入一个`id`即可**

```yaml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
  instance:
    instance-id: payment8001
```

![14对应关系.png](./1. SpringCloud架构【20尚硅谷】.assets/14对应关系.png)

### 2.4.2. 访问信息有IP信息提示

**这里加入一个配置，开启`ip`前缀即可**

```yaml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
      #defaultZone: http://localhost:7001/eureka  # 单机版
  instance:
    instance-id: payment8001
    prefer-ip-address: true     #访问路径可以显示IP地址
```

## 2.5. 服务发现Discovery

**对于注册进`eureka`里面的微服务，可以通过服务发现来获得该服务的信息**

**这里我们以修改`8001`生产者的`Controller`为例子，展现服务发现能展示哪些信息。不仅能获得Eureka后台展示的各个微服务的名称信息，还能通过名称信息获取内部微服务对应的各个服务端的信息。**

```java
@RestController
@Slf4j
public class PaymentController {
    @Value("${server.port}")
    private String serverPort;

    @Resource
    private PaymentService paymentService;

    @Resource
    private DiscoveryClient discoveryClient;

    @PostMapping(value = "/payment/create")
    public CommonResult create(@RequestBody Payment payment){---------}

    @GetMapping(value = "/payment/get/{id}")
    public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id){---------}

    @GetMapping(value = "/payment/discovery")
    public Object discovery() {
        List<String> services = discoveryClient.getServices();
        for (String element : services) {
            System.out.println(element);
        }

        List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
        for (ServiceInstance element : instances) {
            System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t"
                    + element.getUri());
        }
        return this.discoveryClient;
    }
}
```

**同时主程序类需要添加`@EnableDiscoveryClient`注解。**

**<font color="bb000">新版本可以不加这两个注解: `@EnableDiscoveryClient`和`@EnableEurekaClient`</font>**

## 2.6. Eureka自我保护

### 2.6.1. 故障现象

![15自我保护.png](./1. SpringCloud架构【20尚硅谷】.assets/15自我保护.png)

### 2.6.2. 导致原因

**一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存**

**属于CAP里面的AP分支**

![16故障原因1.png](./1. SpringCloud架构【20尚硅谷】.assets/16故障原因1.png)

![17故障原因2.png](./1. SpringCloud架构【20尚硅谷】.assets/17故障原因2.png)

![18故障原因3.png](./1. SpringCloud架构【20尚硅谷】.assets/18故障原因3.png)

### 2.6.3. 怎么禁止自我保护

#### 1. 注册中心eureakeServer端7001

出厂默认，自我保护机制是开启的

```yaml
eureka:
  server:
    enable-self-preservation: true
```

使用如下配置可以禁用自我保护模式

```yaml
eureka: 
  server:
    enable-self-preservation: false 
```

![19关闭效果.png](./1. SpringCloud架构【20尚硅谷】.assets/19关闭效果.png)

#### 2. 生产者客户端eureakeClient端8001

**`Eureka`的默认自动配置 单位为秒**

**`Eureka`客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)**

```yaml
eureka:
  instance:
    lease-renewal-interval-in-seconds: 30
```

**`Eureka`服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务**

```yaml
eureka:
  instance:
    lease-expiration-duration-in-seconds: 90
```

**我们把这两个配置更改，然后手动断开`8001`，即可在`Eureka`网页端发现瞬间注册信息被删除**

# 3. Zookeeper服务注册和发现

## 3.1. 服务提供者

`zookeeper`是一个分布式协调工具，可以实现注册中心功能，这里我们`zookeeper`服务器取代`Eureka`服务器，`zk`作为服务注册中心，建立如下模块

```sh
cloud-provider-payment8004
```

依赖多了`zookeeper`的依赖

```xml
    <dependencies>
        <!-- SpringBoot整合Web组件 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!-- SpringBoot整合zookeeper客户端 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

配置文件和`springcloud`没有太大区别，也是服务名称，端口号，以及对应`zookeeper`的`ip`等属性配置，这里就使用我之前学了`zookeeper`配置的三台集群。

```yaml
#8004表示注册到zookeeper服务器的支付服务提供者端口号
server:
  port: 8004
#服务别名----注册zookeeper到注册中心名称
spring:
  application:
    name: cloud-provider-payment
  cloud:
    zookeeper:
      connect-string: hadoop100:2181,hadoop101:2181,hadoop102:2181
```

主启动以后我们使用别的注册中心一般就不用之前专门给`Eureka`的注解了，直接使用服务发现的注解

```java
@SpringBootApplication
@EnableDiscoveryClient // 该注解用于向使用consul或者zookeeper作为注册中心时注册服务
public class PaymentMain8004 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8004.class, args);
    }
}
```

`Controller`这里就简单完成一个业务即可，获取是否注册到了

```java
@RestController
@Slf4j
public class PaymentController {

    @Value("${server.port}")
    private String serverPort;

    @RequestMapping(value = "/payment/zk")
    public String paymentzk() {
        return "springcloud with zookeeper: " + serverPort + "\t" + UUID.randomUUID().toString();
    }
}
```

补充一下：如果主程序启动如下的错，是因为zookeeper的场景包自带一个`3.5.7beta`版的jar包，优先使用了它的，但如果是比这个版本新就没有问题，如果报错可以在maven排除这个jar包

![20zookeeper.png](./1. SpringCloud架构【20尚硅谷】.assets/20zookeeper.png)

<img src="./1. SpringCloud架构【20尚硅谷】.assets/21jar包.png" alt="21jar包.png" style="zoom: 67%;" />

这里排除包内的选择自己的即可，这里我用的`3.5.7`所以没有报错，这里是给老版本的一个补充

```xml
        <!-- SpringBoot整合zookeeper客户端 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
            <!--先排除自带的zookeeper3.5.3-->
            <exclusions>
                <exclusion>
                    <groupId>org.apache.zookeeper</groupId>
                    <artifactId>zookeeper</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--添加zookeeper3.4.9版本-->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.4.9</version>
        </dependency>
```

**此时运行发现集群的节点可以查询到根目录多了`/services`节点，同时在它下面能查到我们写的服务名称。而且断开主程序过一小段时间，会发现服务对应的`cloud-provider-payment`消失，说明是不带序号的临时节点。能检测到服务上下线。**

![22zookeeper成功.png](./1. SpringCloud架构【20尚硅谷】.assets/22zookeeper成功.png)

测试是否能通过web端注册：http://localhost:8004/payment/zk

![23zookeeper detial.png](./1. SpringCloud架构【20尚硅谷】.assets/23zookeeper detial.png)

## 3.2. 服务消费者

新建

```sh
cloud-consumerzk-order80
```

多了`zookeeper`的客户端包

```xml
        <!-- SpringBoot整合Web组件 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- SpringBoot整合zookeeper客户端 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
            <!--先排除自带的zookeeper-->
            <exclusions>
                <exclusion>
                    <groupId>org.apache.zookeeper</groupId>
                    <artifactId>zookeeper</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--添加zookeeper3.5.7版本-->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.5.7</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

配置文件

```yaml
server:
  port: 80

spring:
  application:
    name: cloud-consumer-order
  cloud:
    #注册到zookeeper地址
    zookeeper:
      connect-string: hadoop100:2181,hadoop101:2181,hadoop102:2181
```

```java
@SpringBootApplication
public class OrderZK80{
    public static void main(String[] args){
        SpringApplication.run(OrderZK80.class,args);
    }
}
```

**这里因为后端是服务器集群，且是微服务之间通信，所以需要引入配置类配置`restTemplate`的对象进入容器，完成跨服务交互和进行负载均衡**

```java
@Configuration
public class ApplicationContextBean {
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
```

`Controller`

```java
@RestController
public class OrderZKController {
    public static final String INVOKE_URL = "http://cloud-provider-payment";

    @Autowired
    private RestTemplate restTemplate;

    @RequestMapping(value = "/consumer/payment/zk")
    public String paymentInfo() {
        String result = restTemplate.getForObject(INVOKE_URL + "/payment/zk", String.class);
        System.out.println("消费者调用支付服务(zookeeper)--->result:" + result);
        return result;
    }
}
```

**验证检测**

![24消费者.png](./1. SpringCloud架构【20尚硅谷】.assets/24消费者.png)

访问测试地址：http://localhost/consumer/payment/zk

# 4. Consul服务注册与发现【中国已经禁用】

## 4.1. Consul简介

![25Consul.png](./1. SpringCloud架构【20尚硅谷】.assets/25Consul.png)

![26特性.png](./1. SpringCloud架构【20尚硅谷】.assets/26特性.png)

1. 服务发现 - 提供HTTP和DNS两种发现方式

2. 健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控

3. KV存储 - Key、Value的存储方式

4. 多数据中心 - Consul支持多数据中心
5. 可视化Web界面

下载地址：https://www.consul.io/downloads.html

官网介绍：https://www.springcloud.cc/spring-cloud-consul.html

# 5. 三个注册中心异同点 

![30异同.png](./1. SpringCloud架构【20尚硅谷】.assets/30异同.png)

## 5.1. CAP

**C:Consistency（强一致性）**

**A:Availability（可用性）**

**P:Partition tolerance（分区容错性）**

**CAP理论关注粒度是数据，而不是整体系统设计的策略**

**<font color="bb000">最多只能同时较好的满足两个。</font>**
**CAP理论的核心是：<font color="bb000">一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，</font>**
**因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：**
**CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。**
**CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。**
**AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。**

## 5.2. 经典CAP图

<img src="./1. SpringCloud架构【20尚硅谷】.assets/27CAP.png" alt="27CAP.png" style="zoom: 67%;" />

**AP(Eureka)**

![28AP.png](./1. SpringCloud架构【20尚硅谷】.assets/28AP.png)

**CP(Zookeeper/Consul)**

![29CP.png](./1. SpringCloud架构【20尚硅谷】.assets/29CP.png)

# 6. Ribbon负载均衡服务调用【过时】

## 6.1. 概述

**Spring Cloud Ribbon**是基于**Netflix Ribbon**实现的一套**客户端负载均衡的工具**。

**通常情况下，客户端请求会先经过Nginx反向代理服务器，然后再由微服务的负载均衡器（如Ribbon或LoadBalancer）将请求转发到具体的微服务实例。这种方式称为软负载均衡，可以提高应用程序的可伸缩性和可靠性。**

简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供**客户端的软件负载均衡算法和服务调用**。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。

官网：https://github.com/Netflix/ribbon/wiki/Getting-Started

Ribbon目前进入维护模式：——> 未来Spring官网的替代方案：`Spring Cloud LoadBalancer`

![31Ribbon概述.png](./1. SpringCloud架构【20尚硅谷】.assets/31Ribbon概述.png)

1. **集中式LB**

即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；

2. **进程内LB**

将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

**<font color="bb000">Ribbon就属于进程内LB</font>，它只是一个类库，<font color="bb000">集成于消费方进程</font>，消费方通过它来获取到服务提供方的地址。**

前面我们讲解过了80通过轮询负载访问8001/8002

负载均衡 + `RestTemplate` 调用

## 6.2. Ribbon负载均衡演示

### 6.2.1. 架构说明

`Ribbon`在工作时分成两步
第一步先选择 `EurekaServer` ,它优先选择在同一个区域内负载较少的`server`.
第二步再根据用户指定的策略，在从 `server` 取到的服务注册列表中选择一个地址。
其中 `Ribbon` 提供了多种策略：比如轮询、随机和根据响应时间加权。

![32架构.png](./1. SpringCloud架构【20尚硅谷】.assets/32架构.png)

之前写样例时候没有引入`spring-cloud-starter-ribbon`也可以使用`ribbon`

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

![32架构.png](./1. SpringCloud架构【20尚硅谷】.assets/32架构.png)

### 6.2.2. 二说`RestTemplate`的使用

官网：https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html

![33resttamplate.png](./1. SpringCloud架构【20尚硅谷】.assets/33resttamplate.png)

#### 1. getForObject方法/getForEntity方法

![34返回对象.png](./1. SpringCloud架构【20尚硅谷】.assets/34返回对象.png)

#### 2. postForObject/postForEntity

![35post.png](./1. SpringCloud架构【20尚硅谷】.assets/35post.png)

#### 3. GET请求方法

```java
<T> T getForObject(String url, Class<T> responseType, Object... uriVariables);
 
<T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables);
 
<T> T getForObject(URI url, Class<T> responseType);
 
<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables);
 
<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables);
 
<T> ResponseEntity<T> getForEntity(URI var1, Class<T> responseType);
```

#### 4. POST请求方法

```java
<T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables);
 
<T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables);
 
<T> T postForObject(URI url, @Nullable Object request, Class<T> responseType);
 
<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables);
 
<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables);
 
<T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType);
```

## 6.3. Ribbon核心组件IRule

IRule：根据特定算法中从服务列表中选取一个要访问的服务

![36tree.png](./1. SpringCloud架构【20尚硅谷】.assets/36tree.png)

### 6.3.1. 算法列表

| 算法                                    | 具体功能                                                     |
| --------------------------------------- | ------------------------------------------------------------ |
| com.netflix.loadbalancer.RoundRobinRule | 轮询                                                         |
| com.netflix.loadbalancer.RandomRule     | 随机                                                         |
| com.netflix.loadbalancer.RetryRule      | 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务 |
| WeightedResponseTimeRule                | 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 |
| BestAvailableRule                       | 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 |
| AvailabilityFilteringRule               | 先过滤掉故障实例，再选择并发较小的实例                       |
| ZoneAvoidanceRule                       | 默认规则,复合判断server所在区域的性能和server的可用性选择服务器 |

### 6.3.1. 如何替换

![37warning.png](./1. SpringCloud架构【20尚硅谷】.assets/37warning.png)

#### 1. 新建包以boot入口包分开

```sh
com.fanxy.myrule
```

#### 2. 上面包下新建MySelfRule规则类

```java
@Configuration
public class MyselfRule {
    
    @Bean
    public IRule myRule(){
        // 随机访问
        return new RandomRule();
    }
}
```

#### 3. 主启动类添加@RibbonClient

**这里必须得和我们在服务端的yaml配置文件的大小写一致，尽管在eureka上显示是大写，但是实际是以配置文件为准，网页端是为了显眼默认显示全大写**

```java
@RibbonClient(name = "cloud-payment-service",configuration=MySelfRule.class)
```

#### 4. 测试

http://localhost/consumer/payment/get/31

## 6.4. Ribbon负载均衡算法【手写实现】

![38Ribbon负载均衡.png](./1. SpringCloud架构【20尚硅谷】.assets/38Ribbon负载均衡.png)

![36tree.png](./1. SpringCloud架构【20尚硅谷】.assets/36tree.png)

**这里源码底层使用了CAS自旋锁，可以学习完JUC后去深入看一下，源码写的很短也很优雅，值得学习。**

暂时等学完JUC再补充这里的笔记。

# 7. OpenFeign服务接口调用

## 7.1. 概述

官网解释：
https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign

github:

https://github.com/spring-cloud/spring-cloud-openfeign

![39Feign.png](./1. SpringCloud架构【20尚硅谷】.assets/39Feign.png)

![40cando.png](./1. SpringCloud架构【20尚硅谷】.assets/40cando.png)

**<font color="bb000">Feign和OpenFeign两者区别</font>**

![41区别.png](./1. SpringCloud架构【20尚硅谷】.assets/41区别.png)

## 7.2. OpenFeign使用步骤

### 7.2.1. 模块初步构建

**Feign在消费端使用**

```sh
cloud-consumer-feign-order80
```

**pom文件这里比起之前多了一个`openfeign`的包**

```xml
<!--openfeign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--eureka client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.atguigu.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!--web-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--一般基础通用配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

**yaml配置文件，这里使用`open-feign`就在配置文件不注册到`eureka`里面作为服务了，这里没注册是因为不给别人提供服务，只需要去`Eureka`调用别人即可**

```yaml
server:
  port: 80

eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
```

**主启动，使用FeignClient需要在主启动上标注<font color="bb000">`@EnableFeignClients`</font>**

```java
@SpringBootApplication
@EnableFeignClients
public class OrderFeignMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderFeignMain80.class, args);
    }
}
```

### 7.2.2. 业务类

**业务逻辑接口+<font color="bb000">@FeignClient配置调用provider服务</font>**

**<font color="bb000">新建PaymentFeignService接口并新增注解@FeignClient</font>**

**因为定义必须是接口，controller一般不好写接口 所以定义在service，这里是相当于把8001和8002的同名的Controller层的方法搬过来了，本质会调用对方同名的方法实现。这里就只写了一个获取方法图省事，而另一个新增的方法懒得写。而我发现不需要写老师写了的`@Component`也照样能注入，估计是这个注解本身就可以通过动态代理生成实现类**

```java
@FeignClient(value = "cloud-payment-service")
public interface PaymentFeignService {

    @GetMapping(value = "/payment/get/{id}")
    CommonResult<Payment> getPaymentById(@PathVariable("id") Long id);
}
```

**控制层Controller**

```java
@RestController
public class PaymentFeignController {

    @Resource
    private PaymentFeignService paymentFeignService;

    @GetMapping("/consumer/payment/get/{id}")
    public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id){
        return paymentFeignService.getPaymentById(id);
    }
}
```

**此时测试，发现是可以实现远程调用，且实现了轮询的负载均衡【底层是用Ribbon实现的】而且并不会把我们的服务端注册在Eureka上作为一个服务 ：http://localhost/consumer/payment/get/1**

## 7.3. OpenFeign超时控制

超时设置，故意设置超时演示出错情况

### 7.3.1. 服务提供方8001故意写暂停程序

```java
    @GetMapping(value = "/payment/feign/timeout")
    public String paymentFeignTimeOut(){

        System.out.println("*****paymentFeignTimeOut from port: "+serverPort);
        //暂停几秒钟线程
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return serverPort;
    }
```

### 7.3.2. 服务消费方80添加超时方法PaymentFeignService

```java
@FeignClient(value = "cloud-payment-service")
public interface PaymentFeignService {

    @GetMapping(value = "/payment/get/{id}")
    CommonResult<Payment> getPaymentById(@PathVariable("id") Long id);

    @GetMapping(value = "/payment/feign/timeout")
    String paymentFeignTimeOut();
}
```

### 7.3.3. 服务消费方80添加超时方法OrderFeignController

<img src="./1. SpringCloud架构【20尚硅谷】.assets/43集成ribbon.png" alt="43集成ribbon.png" style="zoom:67%;" />

默认Feign客户端只等待一秒钟，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。
为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。

yml文件中开启ribbon相关配置【新版已经不集成ribbon了】

```yaml
#设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
#指的是建立连接后从服务器读取到可用资源所用的时间
  ReadTimeout: 5000
#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间
  ConnectTimeout: 5000
```

**<font color="bb000">新版是</font>**

```yaml
feign:
  client:
    config:
      default:
        connect-timeout: 5000
        read-timeout: 5000
```

### 7.3.4. 测试

经测试 添加配置后能正常访问，但是不添加就会报错：

http://localhost:8001/payment/feign/timeout ：耗时3秒能够访问成功

http://localhost/consumer/payment/feign/timeout ：1s后报错

<img src="./1. SpringCloud架构【20尚硅谷】.assets/42Timeout.png" alt="42Timeout.png" style="zoom:67%;" />

## 7.4. OpenFeign日志打印功能

**Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。**
**说白了就是<font color="bb000">Feign接口的调用情况进行监控和输出</font>**

- **NONE：默认的，不显示任何日志；**

- **BASIC：仅记录请求方法、URL、响应状态码及执行时间；**

- **HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；**

- **FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。**

**配置日志`Bean`**

```java
@Configuration
public class FeignConfig {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
```

**可以直接在yaml中配置：**

**其中"`default`”可以换成`FeignClient`中配置的`name`属性，也可以直接用`default`**

**对应的是`FeignClientProperties`类中的`config`属性。该类为`Feign`自动配置类引入的配置项类**

```yaml
feign:
  client:
    config:
      default:
        logger-level: full
```

**配置文件，这里可以使用通配符**

```yaml
logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.fanxy.springcloud.service.PaymentFeignService: debug
```

![44feign日志.png](./1. SpringCloud架构【20尚硅谷】.assets/44feign日志.png)

# 8. Hystrix断路器【已停止维护】

## 8.1. 概述

![45分布式问题.png](./1. SpringCloud架构【20尚硅谷】.assets/45分布式问题.png)

**<font color="bb000">服务雪崩</font>**
多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.

对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。
所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。

![46概述.png](./1. SpringCloud架构【20尚硅谷】.assets/46概述.png)

- 服务降级
- 服务熔断
- 接近实时的监控
- 服务限流
- ....................

官网资料 ：https://github.com/Netflix/Hystrix/wiki/How-To-Use

**<font color="000bb">Hystrix官宣，停更进维</font>**

被动修复bugs，不再接受合并请求，不再发布新版本

## 8.2. Hystrix重要概念

### 8.2.1. 服务降级【fallback】

服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback

哪些情况会出发降级

- 程序运行异常
- 超时
- 服务熔断触发服务降级
- 线程池/信号量打满也会导致服务降级

### 8.2.2. 服务熔断【break】

类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示

就是保险丝

服务的降级->进而熔断->恢复调用链路

### 8.2.3. 服务限流【flowlimit】

秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行

## 8.3. hystrix案例

### 8.3.1. Demo构建

```sh
cloud-provider-hystrix-payment8001
```

POM文件 多引入的`hystrix`的maven

```xml
		<!--hystrix-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
        <!--eureka client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--web-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

**主启动**

```java
@SpringBootApplication
@EnableEurekaClient //本服务启动后会自动注册进eureka服务中
public class PaymentHystrixMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    }
}
```

`Service`

```java
@Service
public class PaymentService {
    /**
     * 正常访问 一切 OK
     *
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id) {
        return "线程池:  " + Thread.currentThread().getName()
                + "  paymentInfo_OK, id:  " + id + "\t" + "O(∩_∩)O";
    }

    /**
     * 超时访问，演示降级
     *
     * @param id
     * @return
     */
    public String paymentInfo_TimeOut(Integer id) {
        int timeNum = 3;
        try {
            TimeUnit.SECONDS.sleep(timeNum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return "线程池:  " + Thread.currentThread().getName()
                + "  paymentInfo_TimeOut, id:  " + id + "\t" + "O(∩_∩)O,耗费" + timeNum + "秒";
    }
}
```

`Controller`

```java
@RestController
@Slf4j
public class PaymentController {

    @Value("server.port")
    private String serverPort;
    @Resource
    private PaymentService paymentService;

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_OK(id);
        log.info("******** result: " + result);
        return result;
    }

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info("******** result: " + result);
        return result;
    }
}
```

**这里启动测试，没有问题，demo建立成功。**

**以上述为根基平台，从正确->错误->降级熔断->恢复**

### 8.3.2. 高并发测试

上述在非高并发情形下，还能勉强满足，但高并发就未必了。

1. Jmeter压测测试

这里设置线程组，200个线程，100次循环，即20000的并发

![47压力测试.png](./1. SpringCloud架构【20尚硅谷】.assets/47压力测试.png)

同时我们去尝试访问没有延迟的 http://localhost:8001/payment/hystrix/ok/1

发现居然开始转圈，有了延迟，为什么？

tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。【tomcat默认10个线程的线程池】

2. Jmeter压测结论

上面还是**服务提供者8001自己测试**，假如此时**外部的消费者80**也来访问，那**消费者**只能干等，最终导致消费端80不满意，服务端8001直接被拖死

### 8.3.3. 消费者80新建加入

```sh
cloud-consumer-feign-hystrix-order80
```

```xml
        <!--openfeign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--hystrix-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
        <!--eureka client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!--web-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--一般基础通用配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

```yaml
server:
  port: 80

eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
```

```java
@SpringBootApplication
@EnableFeignClients
public class OrderHystrixMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderHystrixMain80.class, args);
    }
}
```

`Service`

```java
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT")
public interface PaymentHystrixService {

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id);

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id);
}
```

`Controller`

```java
@RestController
@Slf4j
public class PaymentHystrixController {

    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping("/consumer/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id){
        return paymentHystrixService.paymentInfo_OK(id);
    }

    @GetMapping("/consumer/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentHystrixService.paymentInfo_TimeOut(id);
    }
}
```

普通测试 ：http://localhost/consumer/payment/hystrix/ok/31

此时我们通过80设置jemeter同样的200线程组的并发访问，发现正常访问转圈严重。

**故障现象和导致原因**

8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕

80此时调用8001，客户端访问响应缓慢，转圈圈

**上诉结论**

正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生

**如何解决？解决的要求**

超时导致服务器变慢(转圈) ---> **超时不再等待**

出错(宕机或程序运行出错) ---> **出错要有兜底**

**解决**

对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级

对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级

对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级

### 8.3.4. 服务降级

**降级配置 <font color="bb000"> @HystrixCommand</font>**

#### 1. 8001自身的服务降级

设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback

8001fallback

```java
@Service
public class PaymentService {

    public String paymentInfo_OK(Integer id) {
        return "线程池:  " + Thread.currentThread().getName()
                + "  paymentInfo_OK, id:  " + id + "\t" + "O(∩_∩)O";
    }

    @HystrixCommand(
            fallbackMethod = "paymentInfo_TimeOutHandler",
            commandProperties = {
                    @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
            }
    )
    public String paymentInfo_TimeOut(Integer id) {
        int timeNum = 5;
        try {
            TimeUnit.SECONDS.sleep(timeNum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return "线程池:  " + Thread.currentThread().getName()
                + "  paymentInfo_TimeOut, id:  " + id + "\t" + "O(∩_∩)O,耗费" + timeNum + "秒";
    }

    public String paymentInfo_TimeOutHandler(Integer id) {
        return "线程池:  " + Thread.currentThread().getName()
                + "  paymentInfo_TimeOutHandler, id:  " + id + "\t" + "8001服务超时或服务出错/(ㄒoㄒ)/~~";
    }
}
```

`@HystrixCommand`报异常后如何处理

一旦调用服务方法失败并抛出了错误信息后，会自动调用`@HystrixCommand`标注好的`fallbackMethod`调用类中的指定方法

![48兜底方案.png](./1. SpringCloud架构【20尚硅谷】.assets/48兜底方案.png)

**<font color="bb000">主启动类激活 添加新注解@EnableCircuitBreaker</font>**

**此时测试发现无论是出现整除错误，或者是时间超时，都可以通过我们标注的方法去处理。**

#### 2. 80的服务降级

80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护

题外话：**<font color="bb000">我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务</font>**

配置文件加入【这里其实不加配置文件，主启动加入注解也可以保证能运行，8001那里就没有使用这个配置】

```yaml
feign:
  hystrix:
    enabled: true
```

**<font color="bb000">而这里配置文件需要更改一下Feign的访问时间，这里默认1秒就超时了，具体配置和详细内容见 7.3.3 服务消费方80添加超时方法OrderFeignController</font>**

**<font color="bb000">主启动加入 ：@EnableHystrix，大家可以点@EnableHystrix进去，发现这个注解上面自带@EnableCircuitBreaker，也就是两个都可以</font>**

```java
@SpringBootApplication
@EnableFeignClients
@EnableHystrix
public class OrderHystrixMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderHystrixMain80.class,args);
    }
}
```

**<font color="bb000">服务类加入服务降级的方法</font>**

```java
@RestController
@Slf4j
public class PaymentHystrixController {

    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping("/consumer/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        return paymentHystrixService.paymentInfo_OK(id);
    }

    @GetMapping("/consumer/payment/hystrix/timeout/{id}")
    @HystrixCommand(
            fallbackMethod = "paymentTimeOutFallbackMethod",
            commandProperties = {
                    @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
            }
    )
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        return result;
    }

    public String paymentTimeOutFallbackMethod(@PathVariable("id") Integer id) {
        return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";
    }
}
```

此时测试，果然可以完成80的服务降级。

#### 3.  代码优化

每个业务方法对应一个兜底的方法，代码膨胀，能否完成统一和自定义的分开？

![49注解.png](./1. SpringCloud架构【20尚硅谷】.assets/49注解.png)

服务降级，客户端去调用服务端，碰上服务端宕机或关闭

本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦

未来我们要面对的异常：运行，超时，宕机

修改cloud-consumer-feign-hystrix-order80

**根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，**
**重新新建一个类<font color="bb000">(PaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理</font>**

**<font color="bb000">必须要加`@Component`</font>**

```java
@Component
public class PaymentFallbackService implements PaymentHystrixService {
    @Override
    public String paymentInfo_OK(Integer id) {
        return "服务调用失败，提示来自：cloud-consumer-feign-order80";
    }

    @Override
    public String paymentInfo_TimeOut(Integer id) {
        return "服务调用失败，提示来自：cloud-consumer-feign-order80";
    }
}
```

**同时接口的注解添加属性要声明为当前实现类。**

```java
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT", fallback = PaymentFallbackService.class)
public interface PaymentHystrixService {

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id);

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id);
}
```

访问测试 ：http://localhost/consumer/payment/hystrix/ok/31

**故意关闭8001 ——> 客户端自己调用提示  ——> 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器**

写在controller类内部的处理，并加上默认或者指定降级处理。**如果没有继承service的降级处理，他处理的是服务端与客户端异常**

继承service的降级处理，他处理的是服务端的异常

写在controller类内部的处理，并加上默认或者指定降级处理。**如果存在一个继承service的降级处理，他处理的是客户端自身的异常**

### 8.3.5. 服务熔断

断路器：一句话就是家里的保险丝

![50介绍.png](./1. SpringCloud架构【20尚硅谷】.assets/50介绍.png)

大神论文：https://martinfowler.com/bliki/CircuitBreaker.html

- **调用失败会触发降级，而降级会调用fallback方法**

- **但无论如何降级的流程一定会先调用正常方法再调用fallback方法**

- **假如单位时间内调用失败次数过多，也就是降级次数过多，则触发熔断**

- **熔断以后就会跳过正常方法直接调用fallback方法**

- **所谓“熔断后服务不可用”就是因为跳过了正常方法直接执行fallback**
- **进入半闭半开状态后【默认5秒】，如果这次访问正常，就会关闭，恢复下一个周期，正常运作。如果还是错误，继续进入熔断状态，打开断路器。**

#### 1. 实操

修改cloud-provider-hystrix-payment8001

![51机制.png](./1. SpringCloud架构【20尚硅谷】.assets/51机制.png)

`Service`

```java
    //=========服务熔断
    @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",
            commandProperties = {
                	// 是否开启断路器
                    @HystrixProperty(name = "circuitBreaker.enabled",value = "true"), 
                    // 请求次数
                	@HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),  			
                	// 时间窗口期
                    @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"), 		
                	// 失败率达到多少后熔断
                    @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), 
            }
    )
    public String paymentCircuitBreaker(@PathVariable("id") Integer id) {
        if(id < 0) {
            throw new RuntimeException("******id 不能负数");
        }
        String serialNumber = IdUtil.simpleUUID();

        return Thread.currentThread().getName()+"\t"+"调用成功，流水号: " + serialNumber;
    }
    public String paymentCircuitBreaker_fallback(@PathVariable("id") Integer id) {
        return "id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: " +id;
    }
```

`Controller`

```java
@GetMapping("/payment/circuit/{id}")
public String paymentCircuitBreaker(@PathVariable("id") Integer id) {
    String result = paymentService.paymentCircuitBreaker(id);
    log.info("****result: "+result);
    return result;
}
```

正确 http://localhost:8001/payment/circuit/31

错误 http://localhost:8001/payment/circuit/-31

多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行

#### 2. 总结

熔断类型

1. 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态
2. 熔断关闭：熔断关闭不会对服务进行熔断
3. 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断

![52流程图.png](./1. SpringCloud架构【20尚硅谷】.assets/52流程图.png)

断路器在什么情况下开始起作用

![53熔断器.png](./1. SpringCloud架构【20尚硅谷】.assets/53熔断器.png)

**断路器开启或者关闭的条件**

1. **当满足一定的阀值的时候（默认10秒内超过20个请求次数）**

2. **当失败率达到一定的时候（默认10秒内超过50%的请求失败）**

3. **到达以上阀值，断路器将会开启**

4. **当开启的时候，所有请求都不会进行转发**

5. **一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5**

**断路器打开之后**

![54断路器打开后.png](./1. SpringCloud架构【20尚硅谷】.assets/54断路器打开后.png)

```java
//========================All
@HystrixCommand(fallbackMethod = "str_fallbackMethod",
        groupKey = "strGroupCommand",
        commandKey = "strCommand",
        threadPoolKey = "strThreadPool",

        commandProperties = {
                // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离
                @HystrixProperty(name = "execution.isolation.strategy", value = "THREAD"),
                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）
                @HystrixProperty(name = "execution.isolation.semaphore.maxConcurrentRequests", value = "10"),
                // 配置命令执行的超时时间
                @HystrixProperty(name = "execution.isolation.thread.timeoutinMilliseconds", value = "10"),
                // 是否启用超时时间
                @HystrixProperty(name = "execution.timeout.enabled", value = "true"),
                // 执行超时的时候是否中断
                @HystrixProperty(name = "execution.isolation.thread.interruptOnTimeout", value = "true"),
                // 执行被取消的时候是否中断
                @HystrixProperty(name = "execution.isolation.thread.interruptOnCancel", value = "true"),
                // 允许回调方法执行的最大并发数
                @HystrixProperty(name = "fallback.isolation.semaphore.maxConcurrentRequests", value = "10"),
                // 服务降级是否启用，是否执行回调函数
                @HystrixProperty(name = "fallback.enabled", value = "true"),
                // 是否启用断路器
                @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，
                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。
                @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"),
                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过
                // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50,
                // 就把断路器设置为 "打开" 状态，否则就设置为 "关闭" 状态。
                @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，
                // 会将断路器置为 "半开" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 "打开" 状态，
                // 如果成功就设置为 "关闭" 状态。
                @HystrixProperty(name = "circuitBreaker.sleepWindowinMilliseconds", value = "5000"),
                // 断路器强制打开
                @HystrixProperty(name = "circuitBreaker.forceOpen", value = "false"),
                // 断路器强制关闭
                @HystrixProperty(name = "circuitBreaker.forceClosed", value = "false"),
                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间
                @HystrixProperty(name = "metrics.rollingStats.timeinMilliseconds", value = "10000"),
                // 该属性用来设置滚动时间窗统计指标信息时划分"桶"的数量，断路器在收集指标信息的时候会根据
                // 设置的时间窗长度拆分成多个 "桶" 来累计各度量值，每个"桶"记录了一段时间内的采集指标。
                // 比如 10 秒内拆分成 10 个"桶"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常
                @HystrixProperty(name = "metrics.rollingStats.numBuckets", value = "10"),
                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。
                @HystrixProperty(name = "metrics.rollingPercentile.enabled", value = "false"),
                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。
                @HystrixProperty(name = "metrics.rollingPercentile.timeInMilliseconds", value = "60000"),
                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。
                @HystrixProperty(name = "metrics.rollingPercentile.numBuckets", value = "60000"),
                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，
                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，
                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。
                @HystrixProperty(name = "metrics.rollingPercentile.bucketSize", value = "100"),
                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。
                @HystrixProperty(name = "metrics.healthSnapshot.intervalinMilliseconds", value = "500"),
                // 是否开启请求缓存
                @HystrixProperty(name = "requestCache.enabled", value = "true"),
                // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中
                @HystrixProperty(name = "requestLog.enabled", value = "true"),
        },
        threadPoolProperties = {
                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量
                @HystrixProperty(name = "coreSize", value = "10"),
                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，
                // 否则将使用 LinkedBlockingQueue 实现的队列。
                @HystrixProperty(name = "maxQueueSize", value = "-1"),
                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。
                // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue
                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。
                @HystrixProperty(name = "queueSizeRejectionThreshold", value = "5"),
        }
)
public String strConsumer() {
    return "hello 2020";
}
public String str_fallbackMethod()
{
    return "*****fall back str_fallbackMethod";
}

```

### 8.3.6. 服务限流【高级篇讲解alibaba的Sentinel说明】

## 8.4. hystrix工作流程

官网  https://github.com/Netflix/Hystrix/wiki/How-it-Works

![55原理图.png](./1. SpringCloud架构【20尚硅谷】.assets/55原理图.png)

![56原理表格.png](./1. SpringCloud架构【20尚硅谷】.assets/56原理表格.png)

## 8.5. 服务监控hystrixDashboard

### 8.5.1. 配置监控模块

除了隔离依赖服务的调用以外，Hystrix还提供了**准实时的调用监控（Hystrix Dashboard）**，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。

```sh
cloud-consumer-hystrix-dashboard9001
```

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

```yaml
server:
  port: 9001
```

**HystrixDashboardMain9001+新注解@EnableHystrixDashboard**

**所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置，此前已经配好了**

```xml
   <!-- actuator监控信息完善 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001**

```java
@SpringBootApplication
@EnableHystrixDashboard
public class HystrixDashboardMain9001 {
    public static void main(String[] args) {
        SpringApplication.run(HystrixDashboardMain9001.class, args);
    }
}
```

http://localhost:9001/hystrix

### 8.5.2. 断路器演示(服务监控hystrixDashboard)

修改cloud-provider-hystrix-payment8001

注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径

```java
@SpringBootApplication
@EnableEurekaClient //本服务启动后会自动注册进eureka服务中
@EnableCircuitBreaker//对hystrixR熔断机制的支持
public class MainAppHystrix8001 {
    public static void main(String[] args) {
        SpringApplication.run(MainAppHystrix8001.class,args);
    }

/**
 *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑
 *ServletRegistrationBean因为springboot的默认路径不是"/hystrix.stream"，
 *只要在自己的项目里配置上下面的servlet就可以了
 */
@Bean
public ServletRegistrationBean getServlet() {
    HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
    ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
    registrationBean.setLoadOnStartup(1);
    registrationBean.addUrlMappings("/hystrix.stream");
    registrationBean.setName("HystrixMetricsStreamServlet");
    return registrationBean;
}

}
```

![57监控.png](./1. SpringCloud架构【20尚硅谷】.assets/57监控.png)

1：Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置该属性来降低客户端的网络和CPU消耗。

2：Title：该参数对应了头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题。 

测试填写地址http://localhost:8001/hystrix.stream

测试案例 ：http://localhost:8001/payment/circuit/31

测试案例 ：http://localhost:8001/payment/circuit/-31

![58图.png](./1. SpringCloud架构【20尚硅谷】.assets/58图.png)

七色：每种原色对应一种状态

实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色<黄色<橙色<红色递减。
该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例

曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。

![59说明.png](./1. SpringCloud架构【20尚硅谷】.assets/59说明.png)

![60说明2.png](./1. SpringCloud架构【20尚硅谷】.assets/60说明2.png)

![61大图.png](./1. SpringCloud架构【20尚硅谷】.assets/61大图.png)



# 9. Gateway新一代网关

## 9.1. 概述简介

### 9.1.1. 概述

上一代zuul 1.X https://github.com/Netflix/zuul/wiki

当前gateway https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/

![62网关.png](./1. SpringCloud架构【20尚硅谷】.assets/62网关.png)

Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。
Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等

![63概述.png](./1. SpringCloud架构【20尚硅谷】.assets/63概述.png)

SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。

<img src="./1. SpringCloud架构【20尚硅谷】.assets/64包结构.png" alt="64包结构.png" style="zoom:67%;" />

能干嘛

- 反向代理
- 鉴权
- 流量控制
- 熔断
- 日志监控

![65架构.png](./1. SpringCloud架构【20尚硅谷】.assets/65架构.png)

有Zuul了怎么又出来了gateway

### 9.1.3. 我们为什么选择Gateway？

1. **一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有，用起来也非常的简单便捷。**

Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？

多方面综合考虑Gateway是很理想的网关选择。

2. **Spring Cloud Gateway 具有如下特性：**

基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；
动态路由：能够匹配任何请求属性；
可以对路由指定 Predicate（断言）和 Filter（过滤器）；
集成Hystrix的断路器功能；
集成 Spring Cloud 服务发现功能；
易于编写的 Predicate（断言）和 Filter（过滤器）；
请求限流功能；
支持路径重写。

3. **Spring Cloud Gateway 与 Zuul的区别**

   在SpringCloud Finchley 正式版之前，Spring Cloud 推荐的网关是 Netflix 提供的Zuul：

1、Zuul 1.x，是一个基于阻塞 I/ O 的 API Gateway

2、Zuul 1.x 基于Servlet 2. 5使用阻塞架构它不支持任何长连接(如 WebSocket) Zuul 的设计模式和Nginx较像，每次 I/ O 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身会有第一次加载较慢的情况，使得Zuul 的性能相对较差。

3、Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。 Zuul 2.x的性能较 Zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试， Spring Cloud Gateway 的 RPS（每秒请求数）是Zuul 的 1. 6 倍。

4、Spring Cloud Gateway 建立 在 Spring Framework 5、 Project Reactor 和 Spring Boot 2 之上， 使用非阻塞 API。

5、Spring Cloud Gateway 还 支持 WebSocket， 并且与Spring紧密集成拥有更好的开发体验

![66结构.png](./1. SpringCloud架构【20尚硅谷】.assets/66结构.png)

![67缺点.png](./1. SpringCloud架构【20尚硅谷】.assets/67缺点.png)

GateWay模型

![68webflux.png](./1. SpringCloud架构【20尚硅谷】.assets/68webflux.png)

https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-new-framework

传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的。
**但是在Servlet3.1之后有了异步非阻塞的支持。**而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用java8）

Spring WebFlux 是 Spring 5.0 引入的新的响应式框架，区别于 Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于 Reactor 来实现响应式流规范。

## 9.2. 三大核心概念

### 9.2.1. Route(路由)

路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

### 9.2.2. Predicate(断言)

参考的是Java8的`java.util.function.Predicate`
开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，<font color="bb000">如果请求与断言相匹配则进行路由</font>

### 9.2.3. Filter(过滤)

指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

![69总体](./1. SpringCloud架构【20尚硅谷】.assets/69总体.png)

## 9.3. 工作流程

![70官网.png](./1. SpringCloud架构【20尚硅谷】.assets/70官网.png)

客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。

Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。

Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，
在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。

**核心逻辑 :路由转发+执行过滤器链**

## 9.4. 入门配置

### 9.4.1. 新建module

#### 1. 基础配置

```sh
cloud-gateway-gateway9527
```

网关是不需要配置web-starter和图形化界面的包的。

```xml
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--eureka-client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.fanxy.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!--一般基础配置类-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

```yaml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```

业务类 : 无。主启动要注册到Eureka

```java
@SpringBootApplication
@EnableEurekaClient
public class GateWayMain9527 {
    public static void main(String[] args) {
        SpringApplication.run(GateWayMain9527.class,args);
    }
}
```

#### 2. 9527网关路由映射

cloud-provider-payment8001看看controller的访问地址

- get
- lb

我们目前不想暴露8001端口，希望在8001外面套一层9527

```yaml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```

启动7001 7002

启动8001 ------->cloud-provider-payment8001

启动9527网关

添加网关前------->http://localhost:8001/payment/get/31

添加网关后------->http://localhost:9527/payment/get/31

![71路由](./1. SpringCloud架构【20尚硅谷】.assets/71路由.png)

### 9.4.2. YAML配置说明

Gateway网关路由有两种配置方式：

1. 在配置文件yml中配置

2. 代码中注入RouteLocator的Bean

![72官网案例.png](./1. SpringCloud架构【20尚硅谷】.assets/72官网案例.png)

B站鬼畜区

https://www.bilibili.com/v/kichiku

业务需求

通过9527网关访问到外网的B站鬼畜区 ---->编码

cloud-gateway-gateway9527

```java
@Configuration
public class GateWayConfiguration {
    /**
     * 配置了一个id为route-name的路由规则，
     * 当访问地址 http://localhost:9527/guichu时会自动转发到地址https://www.bilibili.com/v/kichiku
     * @param builder
     * @return
     */
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        RouteLocatorBuilder.Builder routes = builder.routes();

        routes.route("path_route_guichu", r -> r.path("/guichu").uri("https://www.bilibili.com/v/kichiku"));

        return routes.build();

    }
}
```

## 9.5. 通过微服务名实现动态路由

默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<font color="bb000">动态路由进行转发，从而实现动态路由的功能</font>

启动：一个eureka7001 + 两个服务提供者8001/8002

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

**这里开启服务名称的动态路由的配置好像是默认为true，我关闭了仍能实现动态负载均衡**

```yaml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          # uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          # uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```

需要注意的是`uri`的协议为`lb`，表示启用`Gateway`的负载均衡功能。

`lb://serviceName`是`spring cloud gateway`在微服务中自动为我们创建的负载均衡`uri`

测试http://localhost:9527/payment/lb

实现了8001/8002两个端口切换

## 9.6. Predicate的使用

### 9.6.1. 概述

![73是什么.png](./1. SpringCloud架构【20尚硅谷】.assets/73是什么.png)

Route Predicate Factories 是什么？

![74官网介绍.png](./1. SpringCloud架构【20尚硅谷】.assets/74官网介绍.png)

### 9.6.2. 常用的Route Predicate

#### 1. After Route Predicate

![75datatime.png](./1. SpringCloud架构【20尚硅谷】.assets/75datatime.png)

可以直接利用`java8`的时间api获取。

```java
public class TestTime {

    @Test
    public void test1() {
        ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
        System.out.println(zbj);
        // 用指定时区获取当前时间
//        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York"));         
//        System.out.println(zny);
    }
}
```

```yaml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          # uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          # uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
       - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
             - After=2023-07-20T16:38:30.342+08:00[Asia/Shanghai]         
             # 断言，路径相匹配的进行路由


eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka

```

#### 2. Before Route Predicate

雷同

![76before.png](./1. SpringCloud架构【20尚硅谷】.assets/76before.png)

```yaml
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T16:38:30.342+08:00[Asia/Shanghai]         
            # 断言，路径相匹配的进行路由
            - Before=2023-07-22T16:38:30.342+08:00[Asia/Shanghai]       
            # 断言，路径相匹配的进行路由
```

### 9.6.3. Between Route Predicate

雷同不多阐述，一看就懂

```yaml
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - Between=2023-07-20T16:38:30.342+08:00[Asia/Shanghai],2023-07-22T16:38:30.342+08:00[Asia/Shanghai]
```

### 9.6.4. Cookie Route Predicate

**Cookie Route Predicate需要两个参数，一个是 Cookie name ,一个是正则表达式。**
**路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。**

```yaml
          uri: lb://cloud-payment-service          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
            - Cookie=username,fanxy
```

**开发常见测试一般使用 Jmeter，postman，同时也有在命令行的命令 curl**

不带cookies访问

```sh
curl http://localhost:9527/payment/lb
```

![77false.png](./1. SpringCloud架构【20尚硅谷】.assets/77false.png)

带Cookies访问

```sh
curl http://localhost:9527/payment/lb --Cookie "username,fanxy"
```

![78true.png](./1. SpringCloud架构【20尚硅谷】.assets/78true.png)

如果控制台返回乱码【window控制台默认编码GBK，其实就是设置成UTF-8】 ：https://blog.csdn.net/leedee/article/details/82685636 

### 9.6.5. Header Route Predicate

![79Header.png](./1. SpringCloud架构【20尚硅谷】.assets/79Header.png)

两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。

```yaml
          uri: lb://cloud-payment-service          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
        	- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式
```

测试

```sh
curl http://localhost:9527/payment/lb -H "X-Request-Id:123"
```

如果没有带这个请求头，返回404

### 9.6.6. Host Route Predicate

![80host.png](./1. SpringCloud架构【20尚硅谷】.assets/80host.png)

Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。
它通过参数中的主机地址作为匹配规则。

```yaml
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
            - Host=**.fanxy.cloud
```

测试样例

```sh
curl http://localhost:9527/payment/lb -H "Host:www.fanxy.cloud"
```

### 9.6.7. Method Route Predicate

![81get.png](./1. SpringCloud架构【20尚硅谷】.assets/81get.png)

```yaml
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
            - Method=GET
```

测试

```sh
curl -X -POST http://localhost:9527/payment/lb
```

### 9.6.8. Path Route Predicate

**这就是我们此前一直用的**

![82path.png](./1. SpringCloud架构【20尚硅谷】.assets/82path.png)

```yaml
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
```

### 9.6.9. Query Route Predicate

![83query.png](./1. SpringCloud架构【20尚硅谷】.assets/83query.png)

```yaml
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
            - After=2023-07-20T15:38:30.342+08:00[Asia/Shanghai]
            - Query=username, \d+ # 要有参数名username并且值还要是整数才能路由
```

测试样例

```sh
http://localhost:9527/payment/lb?username=31
```

```sh
http://localhost:9527/payment/lb?username=-31
```

### 9.6.10. 小总结

断言：是来控制你的网关像那个服务器转发信息。过滤器：是用来过滤你的请求信息。

说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。

## 9.7. Filter的使用

![84过滤器.png](./1. SpringCloud架构【20尚硅谷】.assets/84过滤器.png)

### 9.7.1. **Spring Cloud Gateway的Filter**

生命周期，Only Two

- pre
- post

种类，Only Two

- 1. **GatewayFilter**  https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#the-addrequestparameter-gatewayfilter-factory![85种类.png](./1. SpringCloud架构【20尚硅谷】.assets/85种类.png)
- 2. GlobalFilter

![85种类.png](./1. SpringCloud架构【20尚硅谷】.assets/85种类.png)



### 9.7.2. 常用的GatewayFilter

**AddRequestParameter**

```yaml
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能
          lower-case-service-id: true #使用小写服务名，默认是大写
      routes:
        - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-provider-payment #匹配后的目标服务地址，供服务的路由地址
          #uri: http://localhost:8001 #匹配后提供服务的路由地址
          filters:
            - AddRequestParameter=X-Request-Id,1024 
            #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为1024
          predicates:
            - Path=/paymentInfo/**        # 断言，路径相匹配的进行路由
            - Method=GET,POST
```

### 9.7.3. 自定义过滤器

自定义全局GlobalFilter

两个主要接口介绍

**implements <font color="bb000">GlobalFilter,Ordered</font>**

```java
@Component //必须加，必须加，必须加
public class MyLogGateWayFilter implements GlobalFilter,Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("time:"+new Date()+"\t 执行了自定义的全局过滤器: "+"MyLogGateWayFilter"+"hello");

        String uname = exchange.getRequest().getQueryParams().getFirst("uname");
        if (uname == null) {
            System.out.println("****用户名为null，无法登录");
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }
	
    // 顺序 越小优先级越高 最小为0 这就是 springmvc的@Order
    @Override
    public int getOrder() {
        return 0;
    }
}
```

测试，这里记得把之前添加的各种规则看一下，别不满足断言，那就没机会到过滤链这一层了。

```sh
http://localhost:9527/payment/lb?uname=fanxy
```

```sh
http://localhost:9527/payment
```

# 10. SpringCloud Config【被Nacos取代】

## 10.1. 概述

分布式系统面临的---配置问题

微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。

SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理....../(ㄒoㄒ)/~~

<img src="./1. SpringCloud架构【20尚硅谷】.assets/86config.png" alt="86config.png" style="zoom:67%;" />

![87概述.png](./1. SpringCloud架构【20尚硅谷】.assets/87概述.png)

**能干嘛**

- 集中管理配置文件
- 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
- 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
- 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
- 将配置信息以REST接口的形式暴露
- post、curl访问刷新均可......

**与GitHub整合配置**

由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式

官网：https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/

## 10.2. Config服务端配置与测试

用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository

```sh
springcloud-config
```

然后clone到本地，然后建立配置文件

![88配置.png](./1. SpringCloud架构【20尚硅谷】.assets/88配置.png)

新建Module模块名字如下，它即为Cloud的配置中心模块cloudConfig Center

```sh
cloud-config-center-3344
```

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

```yaml
server:
  port: 3344

spring:
  application:
    name:  cloud-config-center #注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
          uri: https://github.com/TheFANXY/springcloud-config.git #GitHub上面的git仓库名字
        ####搜索目录
          search-paths:
            - springcloud-config
      ####读取分支
      label: main

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
```

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigCenterMain3344 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigCenterMain3344.class, args);
    }
}
```

**配置hosts，模拟本机为配置管理网站。**

![89hosts.png](./1. SpringCloud架构【20尚硅谷】.assets/89hosts-1689851716455-1.png)

测试通过Config微服务是否可以从GitHub上获取配置内容

启动微服务3344  ------->   http://config-3344.com:3344/main/config-dev.yml

### 10.3.1. 配置读取规则

![90relus.png](./1. SpringCloud架构【20尚硅谷】.assets/90relus.png)

规则一

```sh
/{label}/{application}-{profile}.yml
```

master分支

```sh
http://config-3344.com:3344/master/config-dev.yml
http://config-3344.com:3344/master/config-test.yml
http://config-3344.com:3344/master/config-prod.yml
```

dev分支

```sh
http://config-3344.com:3344/dev/config-dev.yml
http://config-3344.com:3344/dev/config-test.yml
http://config-3344.com:3344/dev/config-prod.yml
```

规则二

配置文件配置了，读取main分支，但是如果你不写，但存在多个分支，默认读取的也是main分支

```sh
/{application}-{profile}.yml
```

```sh
http://config-3344.com:3344/config-dev.yml
http://config-3344.com:3344/config-test.yml
http://config-3344.com:3344/config-prod.yml
http://config-3344.com:3344/config-xxxx.yml(不存在的配置)
```

规则三，从小到大写，默认解析为json串

```sh
/{application}/{profile}[/{label}]
```

```sh
http://config-3344.com:3344/config/dev/master
http://config-3344.com:3344/config/test/master
http://config-3344.com:3344/config/test/dev
```

![91总结.png](./1. SpringCloud架构【20尚硅谷】.assets/91总结.png)

成功实现了用SpringCloud Config通过GitHub获取配置信息

## 10.3. Config客户端配置与测试

新建模块

```sh
cloud-config-client-3355
```

**这里其实也能发现，配置文件这个启动器和3344不同，`spring-cloud-starter-config`没有`server`后缀**

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
```

**<font color="bb000">bootstrap.yml</font>**

![92bootstrap.png](./1. SpringCloud架构【20尚硅谷】.assets/92bootstrap.png)**bootstrap > extension > application**

```yaml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: main #分支名称
      name: config #配置文件名称
      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 #配置中心地址k

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
```

![93说明.png](./1. SpringCloud架构【20尚硅谷】.assets/93说明.png)

```java
@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3355 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigClientMain3355.class,args);
    }
}
```

业务类

```java
@RestController
public class ConfigClientController {
    
    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo() {
        return configInfo;
    }
}
```

成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息

修改config-dev.yml配置并提交到GitHub中，比如加个变量age或者版本号version

![94修改.png](./1. SpringCloud架构【20尚硅谷】.assets/94修改.png)

![95dev.png](./1. SpringCloud架构【20尚硅谷】.assets/95dev.png)

**发现3344端口这里立马发生配置更改，但3355没有变化**

![96dev2.0.png](./1. SpringCloud架构【20尚硅谷】.assets/96dev2.0.png)

**难到每次运维修改配置文件，客户端都需要重启？？噩梦**

## 10.4. Config客户端之动态刷新

修改3355模块

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: main #分支名称
      name: config #配置文件名称
      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取
      uri: http://localhost:3344 #配置中心地址k

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
# 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

业务类添加刷新注解`@RefreshScope`

```java
@RestController
@RefreshScope
public class ConfigClientController {
    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo() {
        return configInfo;
    }
}
```

此时启动，更换3.0版本，但是发现，3355还是没更新？？？

需要运维人员发送Post请求刷新3355

```sh
curl -X POST "http://localhost:3355/actuator/refresh"
```

2021最新的应该是

```sh
curl -X POST "http://localhost:3344/actuator/busrefresh"
```

成功实现了客户端3355刷新到最新配置内容 ---->避免了服务重启

每个微服务都要执行一次post请求，手动刷新？

可否广播，一次通知，处处生效？

我们想大范围的自动刷新，求方法

# 11. SpringCloud Bus 消息总线【被Nacos取代】

## 11.1. 概述

分布式自动刷新配置功能

Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。

Bus支持两种消息代理：RabbitMQ 和 Kafka

![97bus.png](./1. SpringCloud架构【20尚硅谷】.assets/97bus.png)

![98bus ability.png](./1. SpringCloud架构【20尚硅谷】.assets/98bus ability.png)

![99bus原理.png](./1. SpringCloud架构【20尚硅谷】.assets/99bus原理.png)

## 11.2. RabbitMQ环境配置

**这里我没用windows版，在自己的云服务器配置了docker版的rabbitmq**

```sh
mkdir fanxyuse/RabbitMQ
cd fanxyuse/RabbitMQ
vim docker-compose.yml
```

```sh
version: "3.8"
services:
  rabbitmq:
    image: daocloud.io/library/rabbitmq:3.8.8
    container_name: rabbitmq
    restart: always
    volumes:
      - ./data/:/var/lib/rabbitmq/
    ports:
      - 5672:5672
      - 15672:15672
```

```sh
docker-compose up -d
```

```sh
docker exec -it rabbitmq /bin/bash
# 进入rabbitmq的可执行命令目录
cd /opt/rabbitmq/sbin
# 图形化界面默认是关闭的，这里需要开启
./rabbitmq-plugins enable rabbitmq_management
```

**登录默认初始账户     账号   guest      密码      guest          去图形化管理界面删除这个角色**

```sh
http://【ip】:15672
```

**创建账号 【记得改密码】**

```sh
rabbitmqctl add_user admin 123456
```

**设置用户角色**

```sh
rabbitmqctl set_user_tags admin administrator
```

**设置用户权限**

```sh
set_permissions [-p <vhostpath>] <user> <conf> <write> <read>
```

```sh
rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
```

**用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限**

**当前用户和角色**

```sh
rabbitmqctl list_users
```

**docker安装出现无法在管理界面进行管理，需要增加配置**

```sh
因为是使用docker 容器安装的，所有需要进入容器
docker exec -it rabbitmq /bin/bash

进入目录
cd /etc/rabbitmq/conf.d/

执行命令
echo management_agent.disable_metrics_collector = false > management_agent.disable_metrics_collector.conf

退出容器
exit

重启rabbitmq
docker restart rabbitmq
```

## 11.3. SpringCloud Bus动态刷新全局广播

**必须先具备良好的RabbitMQ环境先**

### 11.3.1. 演示广播效果，增加复杂度，再以3355为模板再制作一个3366

```sh
cloud-config-client-3366
```

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

```yml
server:
  port: 3366

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: master #分支名称
      name: config #配置文件名称
      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 #配置中心地址

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

# 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

```java
@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3366 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigClientMain3366.class,args);
    }
}
```

```java
@RestController
@RefreshScope
public class ConfigClientController {
    @Value("${server.port}")
    private String serverPort;

    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String configInfo() {
        return "serverPort: "+serverPort+"\t\n\n configInfo: "+configInfo;
    }
}
```

### 11.3.2. 设计思想

**1）利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置**

<img src="./1. SpringCloud架构【20尚硅谷】.assets/100.png" alt="100.png" style="zoom:67%;" />

**2）利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置**

<img src="./1. SpringCloud架构【20尚硅谷】.assets/101.png" alt="101.png" style="zoom:67%;" />

**图二的架构显然更加适合，图一不适合的原因如下**

**打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。**

**破坏了微服务各节点的对等性。**

**有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改**

### 11.3.3. 给cloud-config-center-3344配置中心服务端添加消息总线支持









### 11.3.4. 给cloud-config-client-3355客户端添加消息总线支持





### 11.3.5. 给cloud-config-client-3366客户端添加消息总线支持





### 11.3.6. 测试







### 11.3.7. 一次修改，广播通知，处处生效











## 11.4. SpringCloud Bus动态刷新定点通知

**不想全部通知，只想定点通知**

**指定具体某一个实例生效而不是全部** 

```sh
公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}
```

**/bus/refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例**

**案例**

**我们这里以刷新运行在3355端口上的config-client为例**

**只通知3355        不通知3366**

```sh
curl -X POST "http://localhost:3344/actuator/bus-refresh/config-client:3355"
```

![102.png](./1. SpringCloud架构【20尚硅谷】.assets/102.png)

**通知总结All**

![103.png](./1. SpringCloud架构【20尚硅谷】.assets/103.png)

# 12. SpringCloud Stream 消息驱动









# 13. SpringCloud Sleuth 分布式请求链路跟踪









# 14. SpringCloud Alibaba 入门简介















# 15. SpringCloud Alibaba Nacos服务注册和配置中心













# 16. SpringCloud Alibaba Sentinel实现熔断与限流











# 17. SpringCloud Alibaba Seata处理分布式事务



















